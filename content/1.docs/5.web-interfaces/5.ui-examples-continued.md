::callout{type="info"}
Это продолжение раздела с примерами интерфейсов. Первую часть вы можете найти в [4.ui-examples.md](/5.web-interfaces/4.ui-examples).
::

## Методы работы с инвентарем (продолжение)

Продолжение класса `Inventory` с методами для работы с инвентарем:

```javascript
class Inventory {
  // ... (начало класса в предыдущем файле)
  
  renderInventory() {
    const grid = document.getElementById('inventoryGrid');
    grid.innerHTML = '';
    
    // Фильтрация предметов по текущей вкладке
    const filteredItems = this.currentFilter === 'all' 
      ? this.items 
      : this.items.filter(item => item.type === this.currentFilter);
    
    // Создание слотов для предметов
    for (let i = 0; i < 24; i++) {
      const slot = document.createElement('div');
      slot.className = 'wg-inventory-slot';
      slot.dataset.index = i;
      
      // Если в этом слоте есть предмет
      const item = filteredItems.find(item => item.slotIndex === i);
      if (item) {
        slot.innerHTML = `
          <div class="wg-item" data-id="${item.id}" draggable="true">
            <img src="${item.icon}" alt="${item.name}">
            ${item.quantity > 1 ? `<span class="wg-item-quantity">${item.quantity}</span>` : ''}
            ${item.equipped ? '<span class="wg-item-equipped">E</span>' : ''}
          </div>
        `;
        
        // Настройка перетаскивания
        this.setupDragAndDrop(slot.querySelector('.wg-item'));
      }
      
      grid.appendChild(slot);
    }
  }
  
  setupDragAndDrop(itemElement) {
    itemElement.addEventListener('dragstart', (e) => {
      this.draggedItem = this.items.find(item => item.id === itemElement.dataset.id);
      e.dataTransfer.setData('text/plain', itemElement.dataset.id);
      setTimeout(() => {
        itemElement.classList.add('dragging');
      }, 0);
    });
    
    itemElement.addEventListener('dragend', () => {
      itemElement.classList.remove('dragging');
      this.draggedItem = null;
    });
  }
  
  setupEventListeners() {
    // Настройка вкладок
    document.querySelectorAll('.wg-tab-button').forEach(button => {
      button.addEventListener('click', () => {
        document.querySelector('.wg-tab-button.active').classList.remove('active');
        button.classList.add('active');
        this.currentFilter = button.dataset.tab;
        this.renderInventory();
      });
    });
    
    // Настройка слотов для приема перетаскиваемых предметов
    document.querySelectorAll('.wg-inventory-slot').forEach(slot => {
      slot.addEventListener('dragover', (e) => {
        e.preventDefault();
        slot.classList.add('drag-over');
      });
      
      slot.addEventListener('dragleave', () => {
        slot.classList.remove('drag-over');
      });
      
      slot.addEventListener('drop', async (e) => {
        e.preventDefault();
        slot.classList.remove('drag-over');
        
        if (this.draggedItem) {
          const targetIndex = parseInt(slot.dataset.index);
          
          // Вызов метода движка для перемещения предмета
          await engine.call('moveInventoryItem', {
            itemId: this.draggedItem.id,
            targetSlot: targetIndex
          });
        }
      });
      
      // Выбор предмета при клике
      slot.addEventListener('click', () => {
        const itemElement = slot.querySelector('.wg-item');
        if (itemElement) {
          const itemId = itemElement.dataset.id;
          this.selectItem(itemId);
        }
      });
    });
    
    // Настройка кнопок действий
    document.getElementById('btnSort').addEventListener('click', () => this.sortItems());
    document.getElementById('btnStack').addEventListener('click', () => this.stackItems());
    document.getElementById('btnDrop').addEventListener('click', () => this.dropSelectedItem());
    document.getElementById('btnUse').addEventListener('click', () => this.useSelectedItem());
    document.getElementById('btnEquip').addEventListener('click', () => this.equipSelectedItem());
  }
  
  selectItem(itemId) {
    this.selectedItem = this.items.find(item => item.id === itemId);
    this.showItemDetails();
  }
  
  showItemDetails() {
    if (!this.selectedItem) return;
    
    document.getElementById('itemName').textContent = this.selectedItem.name;
    document.getElementById('itemType').textContent = this.selectedItem.type;
    document.getElementById('itemImage').src = this.selectedItem.icon;
    document.getElementById('itemDescription').textContent = this.selectedItem.description;
    
    // Отображение характеристик предмета
    const statsContainer = document.getElementById('itemStats');
    statsContainer.innerHTML = '';
    
    if (this.selectedItem.stats) {
      Object.entries(this.selectedItem.stats).forEach(([key, value]) => {
        const statElement = document.createElement('div');
        statElement.className = 'wg-item-stat';
        statElement.innerHTML = `<span class="wg-stat-name">${key}:</span> <span class="wg-stat-value">${value}</span>`;
        statsContainer.appendChild(statElement);
      });
    }
    
    // Показать/скрыть кнопки в зависимости от типа предмета
    document.getElementById('btnUse').style.display = 
      ['consumable', 'potion', 'scroll'].includes(this.selectedItem.type) ? 'block' : 'none';
    
    document.getElementById('btnEquip').style.display = 
      ['weapon', 'armor', 'accessory'].includes(this.selectedItem.type) ? 'block' : 'none';
    
    document.getElementById('btnEquip').textContent = 
      this.selectedItem.equipped ? 'Снять' : 'Экипировать';
    
    // Показать панель деталей
    document.getElementById('itemDetails').classList.add('visible');
  }
  
  updateInventoryStats() {
    const totalWeight = this.items.reduce((sum, item) => sum + (item.weight || 0) * (item.quantity || 1), 0);
    const usedSlots = this.items.length;
    
    document.getElementById('currentWeight').textContent = totalWeight.toFixed(1);
    document.getElementById('usedSlots').textContent = usedSlots;
  }
  
  async sortItems() {
    await engine.call('sortInventory', { criteria: 'type' });
  }
  
  async stackItems() {
    await engine.call('stackInventoryItems');
  }
  
  async dropSelectedItem() {
    if (!this.selectedItem) return;
    
    if (confirm(`Вы уверены, что хотите выбросить ${this.selectedItem.name}?`)) {
      await engine.call('dropInventoryItem', { itemId: this.selectedItem.id });
      this.selectedItem = null;
      document.getElementById('itemDetails').classList.remove('visible');
    }
  }
  
  async useSelectedItem() {
    if (!this.selectedItem) return;
    
    await engine.call('useInventoryItem', { itemId: this.selectedItem.id });
  }
  
  async equipSelectedItem() {
    if (!this.selectedItem) return;
    
    await engine.call('toggleEquipItem', { itemId: this.selectedItem.id });
  }
}
```

## Система диалогов

Пример HTML-структуры для системы диалогов с NPC:

```html
<div class="wg-dialog-system">
  <div class="wg-dialog-portrait">
    <img id="npcPortrait" src="npc/merchant.png" alt="NPC">
    <div class="wg-dialog-name" id="npcName">Торговец</div>
  </div>
  
  <div class="wg-dialog-content">
    <div class="wg-dialog-text" id="dialogText">
      Приветствую тебя, путник! Что привело тебя в наш город?
    </div>
    
    <div class="wg-dialog-options" id="dialogOptions">
      <!-- Варианты ответов будут добавлены динамически -->
    </div>
  </div>
</div>
```

Основные методы для работы с диалогами:

```javascript
class DialogSystem {
  constructor() {
    this.currentDialog = null;
    this.dialogHistory = [];
    this.npcData = null;
    
    this.initialize();
  }
  
  async initialize() {
    // Подписка на события диалога
    engine.subscribe('dialogStarted', (data) => {
      this.startDialog(data.npcId, data.dialogId);
    });
    
    engine.subscribe('dialogEnded', () => {
      this.endDialog();
    });
  }
  
  async startDialog(npcId, dialogId) {
    // Получение данных NPC и диалога
    this.npcData = await engine.call('getNpcData', { npcId });
    this.currentDialog = await engine.call('getDialogData', { dialogId });
    
    // Отображение информации о NPC
    document.getElementById('npcPortrait').src = this.npcData.portrait;
    document.getElementById('npcName').textContent = this.npcData.name;
    
    // Отображение первого сообщения диалога
    this.displayDialogNode(this.currentDialog.startNode);
    
    // Показать диалоговое окно
    document.querySelector('.wg-dialog-system').classList.add('visible');
  }
  
  displayDialogNode(nodeId) {
    const node = this.currentDialog.nodes.find(n => n.id === nodeId);
    if (!node) return;
    
    // Отображение текста диалога
    document.getElementById('dialogText').textContent = node.text;
    
    // Отображение вариантов ответов
    const optionsContainer = document.getElementById('dialogOptions');
    optionsContainer.innerHTML = '';
    
    node.options.forEach(option => {
      // Проверка условий для отображения варианта ответа
      if (option.condition && !this.checkCondition(option.condition)) {
        return;
      }
      
      const optionElement = document.createElement('div');
      optionElement.className = 'wg-dialog-option';
      optionElement.textContent = option.text;
      
      optionElement.addEventListener('click', () => {
        this.selectOption(option);
      });
      
      optionsContainer.appendChild(optionElement);
    });
    
    // Добавление варианта "Выход" если это конечный узел
    if (node.isEnd || node.options.length === 0) {
      const exitOption = document.createElement('div');
      exitOption.className = 'wg-dialog-option wg-dialog-exit';
      exitOption.textContent = 'Завершить разговор';
      
      exitOption.addEventListener('click', () => {
        this.endDialog();
      });
      
      optionsContainer.appendChild(exitOption);
    }
    
    // Анимация появления текста
    wgAnimate.animate(document.getElementById('dialogText'), {
      opacity: [0, 1]
    }, {
      duration: 300,
      easing: 'ease-out'
    });
    
    // Анимация появления вариантов ответов
    wgAnimate.animate(optionsContainer.children, {
      opacity: [0, 1],
      transform: ['translateY(10px)', 'translateY(0)']
    }, {
      duration: 300,
      delay: (el, i) => 100 + i * 50,
      easing: 'ease-out'
    });
  }
  
  checkCondition(condition) {
    // Проверка условия через движок
    return engine.call('checkDialogCondition', { condition });
  }
  
  async selectOption(option) {
    // Добавление выбора в историю диалога
    this.dialogHistory.push({
      text: option.text,
      timestamp: Date.now()
    });
    
    // Выполнение действий, связанных с выбором
    if (option.actions) {
      for (const action of option.actions) {
        await engine.call('executeDialogAction', { action });
      }
    }
    
    // Переход к следующему узлу диалога
    if (option.nextNode) {
      this.displayDialogNode(option.nextNode);
    } else {
      this.endDialog();
    }
  }
  
  endDialog() {
    // Скрытие диалогового окна
    document.querySelector('.wg-dialog-system').classList.remove('visible');
    
    // Сброс данных диалога
    this.currentDialog = null;
    
    // Уведомление движка о завершении диалога
    engine.call('dialogCompleted', {
      npcId: this.npcData.id,
      history: this.dialogHistory
    });
    
    // Сброс истории диалога
    this.dialogHistory = [];
    this.npcData = null;
  }
}

// Инициализация системы диалогов
const dialogSystem = new DialogSystem();
```

## Стилизация компонентов

Wudgine использует CSS переменные для легкой настройки внешнего вида компонентов:

```css
:root {
  /* Основные цвета */
  --wg-primary-color: #4a90e2;
  --wg-secondary-color: #5a6268;
  --wg-danger-color: #e25c5c;
  --wg-success-color: #5ce25c;
  --wg-warning-color: #e2c25c;
  --wg-info-color: #5ccde2;
  
  /* Цвета текста */
  --wg-text-color: #ffffff;
  --wg-text-color-secondary: #b8b8b8;
  --wg-text-color-disabled: #6c757d;
  
  /* Фоновые цвета */
  --wg-bg-color: #1e2124;
  --wg-bg-color-light: #2c3035;
  --wg-bg-color-lighter: #3a3f44;
  
  /* Границы */
  --wg-border-color: #3a3f44;
  --wg-border-radius: 4px;
  
  /* Тени */
  --wg-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  
  /* Размеры шрифтов */
  --wg-font-size-small: 12px;
  --wg-font-size-normal: 14px;
  --wg-font-size-large: 16px;
  --wg-font-size-xlarge: 20px;
}
```

## Следующие шаги

После изучения примеров интерфейсов вы можете:

1. Адаптировать представленные примеры под свои нужды
2. Комбинировать различные компоненты для создания сложных интерфейсов
3. Создать собственные стили с помощью CSS переменных
4. Интегрировать интерфейсы с игровой логикой через JavaScript API

::callout{type="tip"}
Для более сложных интерфейсов рекомендуется использовать современные фреймворки, такие как React или Vue.js, которые можно интегрировать с Wudgine.
::
