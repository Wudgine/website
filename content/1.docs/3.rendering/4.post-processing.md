::callout{type="info"}
В этом разделе описываются эффекты постобработки, доступные в Wudgine.
::

## Система постобработки

Wudgine предлагает мощную систему постобработки для улучшения визуального качества рендеринга. Эффекты постобработки применяются к финальному изображению после завершения основного рендеринга сцены.

### Стек постобработки

```cpp
// Получение стека постобработки
auto& postProcess = renderer.getPostProcessStack();

// Добавление эффектов
postProcess.addEffect<BloomEffect>();
postProcess.addEffect<TonemappingEffect>();
postProcess.addEffect<ColorGradingEffect>();
postProcess.addEffect<VignetteEffect>();

// Настройка порядка эффектов
postProcess.setEffectOrder({
    PostProcessEffectType::Bloom,
    PostProcessEffectType::SSAO,
    PostProcessEffectType::Tonemapping,
    PostProcessEffectType::ColorGrading,
    PostProcessEffectType::Vignette
});

// Включение/отключение эффектов
postProcess.enableEffect(PostProcessEffectType::Bloom, true);
postProcess.enableEffect(PostProcessEffectType::Vignette, false);
```

## Основные эффекты

### Bloom

Bloom создает эффект свечения вокруг ярких областей изображения, имитируя рассеивание света в объективе камеры.

```cpp
// Настройка эффекта Bloom
auto& bloom = postProcess.addEffect<BloomEffect>();
bloom.setThreshold(1.0f);      // Порог яркости для начала эффекта
bloom.setIntensity(0.5f);      // Интенсивность эффекта
bloom.setScatter(0.7f);        // Рассеивание свечения
bloom.setRadius(4);            // Радиус размытия
```

![Пример эффекта Bloom](/images/bloom-effect.png)

### Tonemapping

Тонмаппинг преобразует HDR (High Dynamic Range) изображение в LDR (Low Dynamic Range) для отображения на стандартных мониторах.

```cpp
// Настройка эффекта Tonemapping
auto& tonemap = postProcess.addEffect<TonemappingEffect>();
tonemap.setOperator(TonemappingOperator::ACES); // ACES, Reinhard, Uncharted2, Filmic
tonemap.setExposure(1.0f);                      // Экспозиция
tonemap.setGamma(2.2f);                         // Гамма-коррекция
```

::list{type="primary"}
- ACES: Кинематографический тонмаппинг с хорошей передачей цветов
- Reinhard: Простой и быстрый оператор с мягким сжатием
- Uncharted2: Оператор с хорошей передачей деталей в тенях
- Filmic: Оператор с кинематографическим внешним видом
::

### Color Grading

Color Grading позволяет настраивать цветовую гамму изображения для создания определенного настроения или атмосферы.

```cpp
// Настройка эффекта Color Grading
auto& colorGrading = postProcess.addEffect<ColorGradingEffect>();
colorGrading.setContrast(1.1f);                 // Контраст
colorGrading.setSaturation(1.2f);               // Насыщенность
colorGrading.setGain(Vector3(1.0f, 1.0f, 1.0f)); // Усиление RGB
colorGrading.setOffset(Vector3(0.0f, 0.0f, 0.1f)); // Смещение RGB
colorGrading.setLUT("assets/textures/luts/cinematic.png"); // Применение LUT
```

::card-group
  :::card{icon="i-lucide-sun" title="LUT (Look-Up Table)"}
  Таблица преобразования цветов для быстрого и точного применения цветовых схем.
  :::
  :::card{icon="i-lucide-palette" title="Цветовые кривые"}
  Настройка отдельных каналов RGB для точного контроля над цветами.
  :::
::

### Depth of Field

Depth of Field (глубина резкости) имитирует эффект фокусировки камеры, размывая объекты, находящиеся вне фокуса.

```cpp
// Настройка эффекта Depth of Field
auto& dof = postProcess.addEffect<DepthOfFieldEffect>();
dof.setFocalDistance(10.0f);   // Расстояние фокусировки
dof.setFocalLength(50.0f);     // Фокусное расстояние
dof.setAperture(2.8f);         // Диафрагма (f-число)
dof.setBokehShape(BokehShape::Hexagon); // Форма боке
```

### Motion Blur

Motion Blur создает эффект размытия движения, добавляя реализм быстро движущимся объектам.

```cpp
// Настройка эффекта Motion Blur
auto& motionBlur = postProcess.addEffect<MotionBlurEffect>();
motionBlur.setIntensity(0.3f);         // Интенсивность размытия
motionBlur.setSampleCount(8);          // Количество сэмплов
motionBlur.setVelocityScale(1.0f);     // Масштаб скорости
```

::code-group
```cpp [Объектный Motion Blur]
// Добавление компонента Motion Blur к объекту
auto& motionVector = entity.addComponent<MotionVectorComponent>();
motionVector.setVelocityMultiplier(1.0f);
```

```cpp [Камерный Motion Blur]
// Настройка Motion Blur для камеры
auto& camera = entity.getComponent<CameraComponent>();
camera.enableMotionBlur(true);
camera.setMotionBlurIntensity(0.5f);
```
::

### Screen Space Ambient Occlusion (SSAO)

SSAO добавляет реалистичные мягкие тени в углах и щелях объектов, улучшая восприятие глубины сцены.

```cpp
// Настройка эффекта SSAO
auto& ssao = postProcess.addEffect<SSAOEffect>();
ssao.setRadius(0.5f);          // Радиус эффекта
ssao.setSampleCount(16);       // Количество сэмплов
ssao.setPower(2.0f);           // Сила эффекта
ssao.setBias(0.025f);          // Смещение для предотвращения артефактов
ssao.setBlurSize(4);           // Размер размытия
```

### Другие эффекты

::card-group
  :::card{icon="i-lucide-circle" title="Виньетка"}
  Затемнение краев экрана для фокусировки внимания на центре.
  :::
  :::card{icon="i-lucide-scan" title="Хроматическая аберрация"}
  Имитация оптического искажения, разделяющего цветовые каналы.
  :::
  :::card{icon="i-lucide-tv" title="Зернистость пленки"}
  Добавление шума для имитации зернистости фотопленки.
  :::
  :::card{icon="i-lucide-monitor" title="Сканлайны"}
  Имитация линий развертки старых мониторов.
  :::
::

## Пользовательские эффекты

Wudgine позволяет создавать пользовательские эффекты постобработки:

```cpp
// Создание пользовательского эффекта
class MyCustomEffect : public PostProcessEffect {
public:
    MyCustomEffect() {
        // Загрузка шейдера
        shader = ShaderProgram::create("assets/shaders/post/custom_effect");
        
        // Создание параметров
        addParameter("intensity", 1.0f);
        addParameter("color", Vector3(1.0f, 0.5f, 0.2f));
    }
    
    void render(const RenderContext& context) override {
        // Настройка шейдера
        shader.bind();
        shader.setUniform("u_Intensity", getParameter<float>("intensity"));
        shader.setUniform("u_Color", getParameter<Vector3>("color"));
        shader.setUniform("u_SourceTexture", context.sourceTexture, 0);
        
        // Рендеринг эффекта
        renderFullscreenQuad();
    }
    
private:
    ShaderProgram shader;
};

// Использование пользовательского эффекта
auto& customEffect = postProcess.addEffect<MyCustomEffect>();
customEffect.setParameter("intensity", 0.8f);
customEffect.setParameter("color", Vector3(0.2f, 0.8f, 1.0f));
```

## Профили постобработки

Wudgine позволяет создавать и переключать профили постобработки для разных ситуаций:

```cpp
// Создание профилей постобработки
auto& postProcess = renderer.getPostProcessStack();

// Профиль по умолчанию
auto defaultProfile = postProcess.createProfile("Default");
defaultProfile->addEffect<BloomEffect>().setIntensity(0.3f);
defaultProfile->addEffect<TonemappingEffect>().setOperator(TonemappingOperator::ACES);

// Профиль для подводных сцен
auto underwaterProfile = postProcess.createProfile("Underwater");
underwaterProfile->addEffect<BloomEffect>().setIntensity(0.2f);
underwaterProfile->addEffect<ColorGradingEffect>().setLUT("assets/textures/luts/underwater.png");
underwaterProfile->addEffect<DistortionEffect>().setIntensity(0.05f);
underwaterProfile->addEffect<VignetteEffect>().setIntensity(0.4f);

// Профиль для ночного видения
auto nightVisionProfile = postProcess.createProfile("NightVision");
nightVisionProfile->addEffect<ColorGradingEffect>().setGain(Vector3(0.0f, 1.2f, 0.0f));
nightVisionProfile->addEffect<NoiseEffect>().setIntensity(0.1f);
nightVisionProfile->addEffect<VignetteEffect>().setIntensity(0.7f);

// Переключение профилей
postProcess.setActiveProfile("Default");
// Позже в игре
postProcess.setActiveProfile("Underwater");
// Плавный переход между профилями
postProcess.blendToProfile("NightVision", 2.0f); // Переход за 2 секунды
```

## Следующие шаги

Теперь, когда вы ознакомились с системой постобработки Wudgine, рекомендуем:

::card-group
  :::card{icon="i-lucide-monitor" title="Оптимизация рендеринга" to="/3.rendering/5.rendering-optimization"}
  Изучите методы оптимизации рендеринга для повышения производительности.
  :::
  :::card{icon="i-lucide-box" title="ECS: Глубокое погружение" to="/4.ecs-deep-dive/1.ecs-overview"}
  Познакомьтесь с архитектурой Entity-Component-System.
  :::
::
