::callout{type="info"}
В этом разделе описываются методы оптимизации рендеринга в Wudgine.
::

## Основные техники оптимизации

### Отсечение невидимых объектов (Culling)

Wudgine использует несколько методов отсечения для уменьшения количества объектов, отправляемых на рендеринг:

::card-group
  :::card{icon="i-lucide-eye" title="Frustum Culling"}
  Отсечение объектов, находящихся за пределами видимой области камеры.
  :::
  :::card{icon="i-lucide-box" title="Occlusion Culling"}
  Отсечение объектов, закрытых другими объектами.
  :::
  :::card{icon="i-lucide-layers" title="Portal Culling"}
  Оптимизация для сцен с комнатами и порталами.
  :::
  :::card{icon="i-lucide-monitor" title="Detail Culling"}
  Отсечение мелких деталей на большом расстоянии.
  :::
::

```cpp
// Настройка Frustum Culling
auto& renderer = engine.getRenderer();
renderer.enableFrustumCulling(true);

// Настройка Occlusion Culling
renderer.enableOcclusionCulling(true);
renderer.setOcclusionCullingPrecision(OcclusionPrecision::Medium);

// Настройка Detail Culling
renderer.setDetailCullingDistance(100.0f);
renderer.setDetailCullingSize(0.01f);
```

### Уровни детализации (LOD)

Система LOD автоматически снижает детализацию объектов на большом расстоянии:

```cpp
// Создание LOD для модели
auto& lodGroup = entity.addComponent<LODGroupComponent>();
lodGroup.addLOD(0, "assets/models/character/character_high.mesh", 0.0f);
lodGroup.addLOD(1, "assets/models/character/character_medium.mesh", 10.0f);
lodGroup.addLOD(2, "assets/models/character/character_low.mesh", 30.0f);
lodGroup.addLOD(3, "assets/models/character/character_very_low.mesh", 60.0f);
lodGroup.setCrossFadeEnabled(true);
lodGroup.setCrossFadeDuration(0.5f);
```

### Инстансинг

Инстансинг позволяет эффективно рендерить множество одинаковых объектов:

```cpp
// Создание инстансированного рендерера
auto& instanceRenderer = entity.addComponent<InstancedMeshRendererComponent>();
instanceRenderer.setMesh("assets/models/grass/grass_blade.mesh");
instanceRenderer.setMaterial("assets/materials/grass.mat");

// Добавление инстансов
for (int i = 0; i < 1000; ++i) {
    Transform transform;
    transform.position = Vector3(Random::range(-50.0f, 50.0f), 0.0f, Random::range(-50.0f, 50.0f));
    transform.rotation = Quaternion::fromEuler(0.0f, Random::range(0.0f, 360.0f), 0.0f);
    transform.scale = Vector3(1.0f, Random::range(0.8f, 1.2f), 1.0f);
    
    instanceRenderer.addInstance(transform);
}
```

### Батчинг

Батчинг объединяет несколько объектов в один для уменьшения количества вызовов отрисовки:

::list{type="primary"}
- Static Batching для неподвижных объектов
- Dynamic Batching для движущихся объектов с одинаковыми материалами
- GPU Instancing для множества одинаковых объектов
::

```cpp
// Настройка Static Batching
auto& renderer = engine.getRenderer();
renderer.enableStaticBatching(true);
renderer.setStaticBatchingThreshold(100); // Минимальное количество вершин для батчинга

// Пометка объекта как статического для батчинга
auto& meshRenderer = entity.getComponent<MeshRendererComponent>();
meshRenderer.setStaticBatching(true);
```

## Оптимизация графического конвейера

### Многопоточная подготовка команд

Wudgine использует многопоточность для подготовки команд рендеринга:

```cpp
// Настройка многопоточной подготовки команд
auto& renderer = engine.getRenderer();
renderer.enableMultithreadedRendering(true);
renderer.setRenderThreadCount(4); // Количество потоков для рендеринга
```

### Асинхронные вычисления

Асинхронные вычисления позволяют выполнять некоторые операции параллельно с основным рендерингом:

```cpp
// Настройка асинхронных вычислений
auto& renderer = engine.getRenderer();
renderer.enableAsyncCompute(true);
renderer.setAsyncComputeQueues({
    AsyncComputeQueue::Physics,
    AsyncComputeQueue::ParticleSimulation,
    AsyncComputeQueue::OcclusionCulling
});
```

### Оптимизация шейдеров

::code-group
```glsl [Оптимизация вычислений]
// Оптимизированный фрагментный шейдер
void main() {
    // Предварительные вычисления
    vec3 viewDir = normalize(camera.position - inWorldPos);
    float NdotV = max(dot(normal, viewDir), 0.0);
    
    // Использование предварительно вычисленных значений
    vec3 F0 = mix(vec3(0.04), albedo, metallic);
    vec3 F = fresnelSchlick(NdotV, F0);
    
    // Избегание ветвлений
    float roughnessFactor = mix(roughness, 1.0, step(roughness, 0.01));
}
```

```glsl [Оптимизация текстур]
// Использование текстурных массивов
layout(set = 2, binding = 0) uniform sampler2DArray materialTextures;

void main() {
    // Использование одного семплера для нескольких текстур
    vec3 albedo = texture(materialTextures, vec3(inTexCoord, 0)).rgb;
    vec3 normal = texture(materialTextures, vec3(inTexCoord, 1)).rgb * 2.0 - 1.0;
    float metallic = texture(materialTextures, vec3(inTexCoord, 2)).r;
    float roughness = texture(materialTextures, vec3(inTexCoord, 3)).r;
}
```
::

## Оптимизация ресурсов

### Управление текстурами

::list{type="success"}
- Текстурные атласы для уменьшения переключений текстур
- Сжатие текстур (BC7, ASTC) для уменьшения использования памяти
- Мипмаппинг для оптимизации на разных расстояниях
- Потоковая загрузка текстур для больших открытых миров
::

```cpp
// Создание текстурного атласа
TextureAtlas atlas = TextureAtlas::create(2048, 2048);
atlas.addTexture("grass", "assets/textures/terrain/grass.png");
atlas.addTexture("dirt", "assets/textures/terrain/dirt.png");
atlas.addTexture("rock", "assets/textures/terrain/rock.png");
atlas.addTexture("sand", "assets/textures/terrain/sand.png");
atlas.build();

// Использование текстурного атласа
auto& material = entity.getComponent<MeshRendererComponent>().getMaterial();
material.setTextureAtlas("albedo", atlas);
material.setTextureRegion("albedo", "grass");
```

### Управление мешами

Оптимизация меш-данных для улучшения производительности:

::list{type="primary"}
- Оптимизация топологии для уменьшения количества вершин и треугольников
- Предварительное вычисление тангентов и бинормалей
- Сжатие вершинных данных
- Уровни детализации (LOD)
::

```cpp
// Оптимизация меша
Mesh mesh = Mesh::load("assets/models/character/character.mesh");
mesh.optimize();
mesh.generateLODs(4); // Генерация 4 уровней LOD
mesh.compressVertexData();
mesh.save("assets/models/character/character_optimized.mesh");
```

## Профилирование и отладка

### Инструменты профилирования

Wudgine предоставляет встроенные инструменты для профилирования рендеринга:

```cpp
// Включение профилирования рендеринга
auto& profiler = engine.getProfiler();
profiler.enableRendererProfiling(true);

// Получение статистики рендеринга
auto stats = profiler.getRendererStats();
Debug::log("Draw calls: {}", stats.drawCalls);
Debug::log("Triangles: {}", stats.triangles);
Debug::log("Vertices: {}", stats.vertices);
Debug::log("Render time: {} ms", stats.renderTimeMs);
```

### Визуализация отладки

```cpp
// Включение визуализации отладки
auto& debugRenderer = engine.getDebugRenderer();
debugRenderer.enableFrustumVisualization(true);
debugRenderer.enableOcclusionCullingVisualization(true);
debugRenderer.enableLODVisualization(true);
```

![Визуализация отладки](/images/debug-visualization.png)

## Оптимизация для разных платформ

### Мобильные устройства

Рекомендации для оптимизации на мобильных устройствах:

::list{type="warning"}
- Уменьшение разрешения рендеринга
- Использование облегченных шейдеров
- Агрессивное отсечение и LOD
- Оптимизация для тайловых рендереров
- Уменьшение количества прозрачных объектов
::

```cpp
// Настройка для мобильных устройств
if (Platform::isMobile()) {
    auto& renderer = engine.getRenderer();
    renderer.setRenderScale(0.75f); // Рендеринг в 75% от разрешения экрана
    renderer.setShaderQuality(ShaderQuality::Low);
    renderer.setLODBias(2.0f); // Более агрессивное переключение LOD
    renderer.setMaxLights(4);
    renderer.disableEffect(PostProcessEffectType::SSAO);
    renderer.disableEffect(PostProcessEffectType::DepthOfField);
}
```

### Консоли

Оптимизация для игровых консолей:

```cpp
// Настройка для консолей
if (Platform::isConsole()) {
    auto& renderer = engine.getRenderer();
    
    if (Platform::getConsoleType() == ConsoleType::HighEnd) {
        // Настройки для высокопроизводительных консолей
        renderer.setRenderResolution(RenderResolution::UHD);
        renderer.enableRayTracedShadows(true);
        renderer.enableRayTracedAmbientOcclusion(true);
    } else {
        // Настройки для консолей среднего уровня
        renderer.setRenderResolution(RenderResolution::FullHD);
        renderer.setTargetFrameRate(60);
    }
    
    // Оптимизация для унифицированной памяти
    renderer.enableUnifiedMemoryOptimizations(true);
}
```

## Следующие шаги

Теперь, когда вы ознакомились с методами оптимизации рендеринга в Wudgine, рекомендуем:

::card-group
  :::card{icon="i-lucide-box" title="ECS: Глубокое погружение" to="/4.ecs-deep-dive/1.ecs-overview"}
  Изучите архитектуру Entity-Component-System.
  :::
  :::card{icon="i-lucide-layout" title="Веб-интерфейсы" to="/5.web-interfaces/1.web-overview"}
  Познакомьтесь с системой веб-интерфейсов Wudgine.
  :::
::
