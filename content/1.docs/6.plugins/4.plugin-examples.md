::alert{type="info"}
В этом разделе представлены примеры плагинов для Wudgine, которые помогут вам понять, как создавать собственные расширения.
::

## Плагин для постобработки

Этот пример демонстрирует создание плагина для добавления эффектов постобработки:

### Структура плагина

```
PostProcessPlugin/
├── CMakeLists.txt
├── plugin.json
├── src/
│   ├── PostProcessPlugin.h
│   ├── PostProcessPlugin.cpp
│   ├── Effects/
│   │   ├── BloomEffect.h
│   │   ├── BloomEffect.cpp
│   │   ├── VignetteEffect.h
│   │   └── VignetteEffect.cpp
│   └── Components/
│       ├── PostProcessComponent.h
│       └── PostProcessComponent.cpp
└── resources/
    ├── shaders/
    │   ├── bloom.frag
    │   └── vignette.frag
    └── icons/
        └── post_process.png
```

### Файл манифеста

```json
{
  "name": "PostProcessPlugin",
  "version": "1.0.0",
  "author": "Wudgine Team",
  "description": "Плагин для добавления эффектов постобработки",
  "engineVersion": "1.0.0",
  "dependencies": [],
  "entryPoint": "PostProcessPlugin"
}
```

### Основной класс плагина

```cpp
// PostProcessPlugin.h
#pragma once

#include <Wudgine/Plugin/IPlugin.h>
#include <Wudgine/Core/ServiceLocator.h>
#include <Wudgine/Render/RenderPipeline.h>

class PostProcessPlugin : public Wudgine::Plugin::IPlugin {
public:
    PostProcessPlugin();
    ~PostProcessPlugin();

    // Реализация интерфейса IPlugin
    bool Initialize() override;
    void Shutdown() override;
    
    const char* GetName() const override { return "PostProcessPlugin"; }
    const char* GetVersion() const override { return "1.0.0"; }
    const char* GetAuthor() const override { return "Wudgine Team"; }
    const char* GetDescription() const override { return "Плагин для добавления эффектов постобработки"; }
    
    // Настройки плагина
    void RenderSettings() override;

private:
    // Регистрация компонентов и систем
    void RegisterComponents();
    void RegisterSystems();
    void RegisterEditorTools();
    
    // Загрузка ресурсов
    bool LoadResources();
    
    // Настройки плагина
    struct Settings {
        bool enableBloom = true;
        float bloomIntensity = 1.0f;
        bool enableVignette = true;
        float vignetteIntensity = 0.5f;
        
        template<typename Archive>
        void serialize(Archive& ar) {
            ar & enableBloom;
            ar & bloomIntensity;
            ar & enableVignette;
            ar & vignetteIntensity;
        }
    };
    
    Settings m_settings;
};
```

```cpp
// PostProcessPlugin.cpp
#include "PostProcessPlugin.h"
#include "Components/PostProcessComponent.h"
#include "Effects/BloomEffect.h"
#include "Effects/VignetteEffect.h"

#include <Wudgine/Core/Log.h>
#include <Wudgine/Core/SettingsManager.h>
#include <Wudgine/ECS/ComponentRegistry.h>
#include <Wudgine/Editor/EditorToolManager.h>
#include <Wudgine/Resource/ResourceManager.h>
#include <imgui.h>

PostProcessPlugin::PostProcessPlugin() = default;
PostProcessPlugin::~PostProcessPlugin() = default;

bool PostProcessPlugin::Initialize() {
    WG_LOG_INFO("[PostProcessPlugin] Инициализация...");
    
    // Загрузка настроек
    if (Wudgine::Core::SettingsManager::GetInstance().HasPluginSettings(GetName())) {
        m_settings = Wudgine::Core::SettingsManager::GetInstance().LoadPluginSettings<Settings>(GetName());
    }
    
    // Регистрация компонентов и систем
    RegisterComponents();
    RegisterSystems();
    
    // Регистрация инструментов редактора (если в режиме редактора)
    if (Wudgine::Core::IsEditor()) {
        RegisterEditorTools();
    }
    
    // Загрузка ресурсов
    if (!LoadResources()) {
        WG_LOG_ERROR("[PostProcessPlugin] Ошибка загрузки ресурсов");
        return false;
    }
    
    // Регистрация хуков рендеринга
    auto& renderPipeline = Wudgine::Render::RenderPipeline::GetInstance();
    
    // Добавление эффектов постобработки в конвейер рендеринга
    if (m_settings.enableBloom) {
        renderPipeline.AddPostProcessEffect(new BloomEffect(m_settings.bloomIntensity));
    }
    
    if (m_settings.enableVignette) {
        renderPipeline.AddPostProcessEffect(new VignetteEffect(m_settings.vignetteIntensity));
    }
    
    WG_LOG_INFO("[PostProcessPlugin] Инициализация завершена");
    return true;
}

void PostProcessPlugin::Shutdown() {
    WG_LOG_INFO("[PostProcessPlugin] Завершение работы...");
    
    // Сохранение настроек
    Wudgine::Core::SettingsManager::GetInstance().SavePluginSettings(GetName(), m_settings);
    
    // Удаление эффектов из конвейера рендеринга
    auto& renderPipeline = Wudgine::Render::RenderPipeline::GetInstance();
    renderPipeline.RemoveAllPostProcessEffects();
    
    WG_LOG_INFO("[PostProcessPlugin] Завершение работы завершено");
}

void PostProcessPlugin::RegisterComponents() {
    // Регистрация компонента постобработки
    Wudgine::ECS::ComponentRegistry::GetInstance().RegisterComponent<PostProcessComponent>(
        "PostProcessComponent",
        []() { return new PostProcessComponent(); }
    );
}

void PostProcessPlugin::RegisterSystems() {
    // В этом примере системы не используются
}

void PostProcessPlugin::RegisterEditorTools() {
    // Регистрация инспектора для компонента постобработки
    class PostProcessInspector : public Wudgine::Editor::ComponentInspector {
    public:
        bool CanInspect(Wudgine::ECS::Component* component) override {
            return dynamic_cast<PostProcessComponent*>(component) != nullptr;
        }
        
        void Render(Wudgine::ECS::Component* component) override {
            auto* ppComponent = static_cast<PostProcessComponent*>(component);
            
            // Отрисовка полей компонента
            bool enableBloom = ppComponent->IsBloomEnabled();
            if (ImGui::Checkbox("Включить Bloom", &enableBloom)) {
                ppComponent->SetBloomEnabled(enableBloom);
                MarkDirty();
            }
            
            float bloomIntensity = ppComponent->GetBloomIntensity();
            if (ImGui::SliderFloat("Интенсивность Bloom", &bloomIntensity, 0.0f, 2.0f)) {
                ppComponent->SetBloomIntensity(bloomIntensity);
                MarkDirty();
            }
            
            bool enableVignette = ppComponent->IsVignetteEnabled();
            if (ImGui::Checkbox("Включить Виньетку", &enableVignette)) {
                ppComponent->SetVignetteEnabled(enableVignette);
                MarkDirty();
            }
            
            float vignetteIntensity = ppComponent->GetVignetteIntensity();
            if (ImGui::SliderFloat("Интенсивность Виньетки", &vignetteIntensity, 0.0f, 1.0f)) {
                ppComponent->SetVignetteIntensity(vignetteIntensity);
                MarkDirty();
            }
        }
    };
    
    Wudgine::Editor::InspectorManager::GetInstance().RegisterInspector(new PostProcessInspector());
}

bool PostProcessPlugin::LoadResources() {
    // Загрузка шейдеров
    auto& resourceManager = Wudgine::Resource::ResourceManager::GetInstance();
    
    if (!resourceManager.LoadShader("plugins/PostProcessPlugin/shaders/bloom.frag")) {
        WG_LOG_ERROR("[PostProcessPlugin] Не удалось загрузить шейдер bloom.frag");
        return false;
    }
    
    if (!resourceManager.LoadShader("plugins/PostProcessPlugin/shaders/vignette.frag")) {
        WG_LOG_ERROR("[PostProcessPlugin] Не удалось загрузить шейдер vignette.frag");
        return false;
    }
    
    return true;
}

void PostProcessPlugin::RenderSettings() {
    ImGui::Checkbox("Включить Bloom", &m_settings.enableBloom);
    
    if (m_settings.enableBloom) {
        ImGui::SliderFloat("Интенсивность Bloom", &m_settings.bloomIntensity, 0.0f, 2.0f);
    }
    
    ImGui::Checkbox("Включить Виньетку", &m_settings.enableVignette);
    
    if (m_settings.enableVignette) {
        ImGui::SliderFloat("Интенсивность Виньетки", &m_settings.vignetteIntensity, 0.0f, 1.0f);
    }
    
    // Применение изменений
    auto& renderPipeline = Wudgine::Render::RenderPipeline::GetInstance();
    renderPipeline.UpdatePostProcessEffects();
    
    // Сохранение настроек
    Wudgine::Core::SettingsManager::GetInstance().SavePluginSettings(GetName(), m_settings);
}

// Экспорт плагина
extern "C" {
    WUDGINE_PLUGIN_API Wudgine::Plugin::IPlugin* CreatePlugin() {
        return new PostProcessPlugin();
    }
}
```

### Компонент постобработки

```cpp
// PostProcessComponent.h
#pragma once

#include <Wudgine/ECS/Component.h>
#include <Wudgine/Core/Serializable.h>

class PostProcessComponent : public Wudgine::ECS::Component, public Wudgine::Core::Serializable {
public:
    PostProcessComponent();
    ~PostProcessComponent() override;
    
    // Bloom
    bool IsBloomEnabled() const { return m_bloomEnabled; }
    void SetBloomEnabled(bool enabled);
    
    float GetBloomIntensity() const { return m_bloomIntensity; }
    void SetBloomIntensity(float intensity);
    
    // Vignette
    bool IsVignetteEnabled() const { return m_vignetteEnabled; }
    void SetVignetteEnabled(bool enabled);
    
    float GetVignetteIntensity() const { return m_vignetteIntensity; }
    void SetVignetteIntensity(float intensity);
    
    // Сериализация
    template<typename Archive>
    void serialize(Archive& ar) {
        ar & m_bloomEnabled;
        ar & m_bloomIntensity;
        ar & m_vignetteEnabled;
        ar & m_vignetteIntensity;
    }

private:
    bool m_bloomEnabled;
    float m_bloomIntensity;
    bool m_vignetteEnabled;
    float m_vignetteIntensity;
};
```

```cpp
// PostProcessComponent.cpp
#include "PostProcessComponent.h"
#include <Wudgine/Render/RenderPipeline.h>

PostProcessComponent::PostProcessComponent()
    : m_bloomEnabled(true)
    , m_bloomIntensity(1.0f)
    , m_vignetteEnabled(true)
    , m_vignetteIntensity(0.5f)
{
}

PostProcessComponent::~PostProcessComponent() = default;

void PostProcessComponent::SetBloomEnabled(bool enabled) {
    m_bloomEnabled = enabled;
    
    // Обновление эффекта в конвейере рендеринга
    auto& renderPipeline = Wudgine::Render::RenderPipeline::GetInstance();
    if (enabled) {
        renderPipeline.EnablePostProcessEffect("Bloom");
    } else {
        renderPipeline.DisablePostProcessEffect("Bloom");
    }
}

void PostProcessComponent::SetBloomIntensity(float intensity) {
    m_bloomIntensity = intensity;
    
    // Обновление параметров эффекта
    auto& renderPipeline = Wudgine::Render::RenderPipeline::GetInstance();
    renderPipeline.SetPostProcessEffectParameter("Bloom", "intensity", intensity);
}

void PostProcessComponent::SetVignetteEnabled(bool enabled) {
    m_vignetteEnabled = enabled;
    
    // Обновление эффекта в конвейере рендеринга
    auto& renderPipeline = Wudgine::Render::RenderPipeline::GetInstance();
    if (enabled) {
        renderPipeline.EnablePostProcessEffect("Vignette");
    } else {
        renderPipeline.DisablePostProcessEffect("Vignette");
    }
}

void PostProcessComponent::SetVignetteIntensity(float intensity) {
    m_vignetteIntensity = intensity;
    
    // Обновление параметров эффекта
    auto& renderPipeline = Wudgine::Render::RenderPipeline::GetInstance();
    renderPipeline.SetPostProcessEffectParameter("Vignette", "intensity", intensity);
}
```

### Файл CMake

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.14)
project(PostProcessPlugin)

# Версия C++
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Исходные файлы
set(SOURCES
    src/PostProcessPlugin.cpp
    src/Components/PostProcessComponent.cpp
    src/Effects/BloomEffect.cpp
    src/Effects/VignetteEffect.cpp
)

# Заголовочные файлы
set(HEADERS
    src/PostProcessPlugin.h
    src/Components/PostProcessComponent.h
    src/Effects/BloomEffect.h
    src/Effects/VignetteEffect.h
)

# Путь к Wudgine SDK
set(WUDGINE_SDK_PATH "${CMAKE_CURRENT_SOURCE_DIR}/../../WudgineSDK" CACHE PATH "Путь к Wudgine SDK")

# Включение директорий заголовочных файлов
include_directories(
    ${WUDGINE_SDK_PATH}/include
    ${CMAKE_CURRENT_SOURCE_DIR}/src
)

# Создание библиотеки плагина
add_library(${PROJECT_NAME} SHARED ${SOURCES} ${HEADERS})

# Определение макроса для экспорта API плагина
target_compile_definitions(${PROJECT_NAME} PRIVATE WUDGINE_PLUGIN_EXPORTS)

# Связывание с библиотеками Wudgine
target_link_libraries(${PROJECT_NAME} 
    ${WUDGINE_SDK_PATH}/lib/WudgineCore
    ${WUDGINE_SDK_PATH}/lib/WudgineRender
    ${WUDGINE_SDK_PATH}/lib/WudgineECS
)

# Копирование ресурсов плагина
add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_directory
    ${CMAKE_CURRENT_SOURCE_DIR}/resources
    ${CMAKE_BINARY_DIR}/plugins/${PROJECT_NAME}/resources
)

# Копирование файла манифеста
add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy
    ${CMAKE_CURRENT_SOURCE_DIR}/plugin.json
    ${CMAKE_BINARY_DIR}/plugins/${PROJECT_NAME}/plugin.json
)

# Копирование библиотеки плагина
add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy
    $<TARGET_FILE:${PROJECT_NAME}>
    ${CMAKE_BINARY_DIR}/plugins/${PROJECT_NAME}/$<TARGET_FILE_NAME:${PROJECT_NAME}>
)
```

## Плагин для физики

Этот пример демонстрирует создание плагина для интеграции физического движка:

### Структура плагина

```
PhysicsPlugin/
├── CMakeLists.txt
├── plugin.json
├── src/
│   ├── PhysicsPlugin.h
│   ├── PhysicsPlugin.cpp
│   ├── Components/
│   │   ├── RigidBodyComponent.h
│   │   ├── RigidBodyComponent.cpp
│   │   ├── ColliderComponent.h
│   │   └── ColliderComponent.cpp
│   └── Systems/
│       ├── PhysicsSystem.h
│       └── PhysicsSystem.cpp
└── resources/
    └── icons/
        └── physics.png
```

### Файл манифеста

```json
{
  "name": "PhysicsPlugin",
  "version": "1.0.0",
  "author": "Wudgine Team",
  "description": "Плагин для интеграции физического движка",
  "engineVersion": "1.0.0",
  "dependencies": [],
  "entryPoint": "PhysicsPlugin"
}
```

### Основной класс плагина

```cpp
// PhysicsPlugin.h
#pragma once

#include <Wudgine/Plugin/IPlugin.h>

class PhysicsPlugin : public Wudgine::Plugin::IPlugin {
public:
    PhysicsPlugin();
    ~PhysicsPlugin();

    // Реализация интерфейса IPlugin
    bool Initialize() override;
    void Shutdown() override;
    
    const char* GetName() const override { return "PhysicsPlugin"; }
    const char* GetVersion() const override { return "1.0.0"; }
    const char* GetAuthor() const override { return "Wudgine Team"; }
    const char* GetDescription() const override { return "Плагин для интеграции физического движка"; }
    
    // Настройки плагина
    void RenderSettings() override;

private:
    // Регистрация компонентов и систем
    void RegisterComponents();
    void RegisterSystems();
    void RegisterEditorTools();
    
    // Настройки плагина
    struct Settings {
        float gravity = -9.81f;
        int solverIterations = 10;
        bool enableContinuousDetection = true;
        
        template<typename Archive>
        void serialize(Archive& ar) {
            ar & gravity;
            ar & solverIterations;
            ar & enableContinuousDetection;
        }
    };
    
    Settings m_settings;
};
```

```cpp
// PhysicsPlugin.cpp
#include "PhysicsPlugin.h"
#include "Components/RigidBodyComponent.h"
#include "Components/ColliderComponent.h"
#include "Systems/PhysicsSystem.h"

#include <Wudgine/Core/Log.h>
#include <Wudgine/Core/SettingsManager.h>
#include <Wudgine/ECS/ComponentRegistry.h>
#include <Wudgine/ECS/SystemRegistry.h>
#include <Wudgine/Editor/EditorToolManager.h>
#include <imgui.h>

PhysicsPlugin::PhysicsPlugin() = default;
PhysicsPlugin::~PhysicsPlugin() = default;

bool PhysicsPlugin::Initialize() {
    WG_LOG_INFO("[PhysicsPlugin] Инициализация...");
    
    // Загрузка настроек
    if (Wudgine::Core::SettingsManager::GetInstance().HasPluginSettings(GetName())) {
        m_settings = Wudgine::Core::SettingsManager::GetInstance().LoadPluginSettings<Settings>(GetName());
    }
    
    // Регистрация компонентов и систем
    RegisterComponents();
    RegisterSystems();
    
    // Регистрация инструментов редактора (если в режиме редактора)
    if (Wudgine::Core::IsEditor()) {
        RegisterEditorTools();
    }
    
    // Инициализация физического движка с настройками
    PhysicsSystem::GetInstance().SetGravity(m_settings.gravity);
    PhysicsSystem::GetInstance().SetSolverIterations(m_settings.solverIterations);
    PhysicsSystem::GetInstance().SetContinuousDetection(m_settings.enableContinuousDetection);
    
    WG_LOG_INFO("[PhysicsPlugin] Инициализация завершена");
    return true;
}

void PhysicsPlugin::Shutdown() {
    WG_LOG_INFO("[PhysicsPlugin] Завершение работы...");
    
    // Сохранение настроек
    Wudgine::Core::SettingsManager::GetInstance().SavePluginSettings(GetName(), m_settings);
    
    // Завершение работы физического движка
    PhysicsSystem::GetInstance().Shutdown();
    
    WG_LOG_INFO("[PhysicsPlugin] Завершение работы завершено");
}

void PhysicsPlugin::RegisterComponents() {
    // Регистрация компонентов физики
    Wudgine::ECS::ComponentRegistry::GetInstance().RegisterComponent<RigidBodyComponent>(
        "RigidBodyComponent",
        []() { return new RigidBodyComponent(); }
    );
    
    Wudgine::ECS::ComponentRegistry::GetInstance().RegisterComponent<ColliderComponent>(
        "ColliderComponent",
        []() { return new ColliderComponent(); }
    );
}

void PhysicsPlugin::RegisterSystems() {
    // Регистрация системы физики
    Wudgine::ECS::SystemRegistry::GetInstance().RegisterSystem<PhysicsSystem>(
        "PhysicsSystem",
        []() { return &PhysicsSystem::GetInstance(); }
    );
}

void PhysicsPlugin::RegisterEditorTools() {
    // Регистрация инспектора для компонента твердого тела
    class RigidBodyInspector : public Wudgine::Editor::ComponentInspector {
    public:
        bool CanInspect(Wudgine::ECS::Component* component) override {
            return dynamic_cast<RigidBodyComponent*>(component) != nullptr;
        }
        
        void Render(Wudgine::ECS::Component* component) override {
            auto* rbComponent = static_cast<RigidBodyComponent*>(component);
            
            // Отрисовка полей компонента
            float mass = rbComponent->GetMass();
            if (ImGui::DragFloat("Масса", &mass, 0.1f, 0.0f, 1000.0f)) {
                rbComponent->SetMass(mass);
                MarkDirty();
            }
            
            bool isKinematic = rbComponent->IsKinematic();
            if (ImGui::Checkbox("Кинематический", &isKinematic)) {
                rbComponent->SetKinematic(isKinematic);
                MarkDirty();
            }
            
            float linearDamping = rbComponent->GetLinearDamping();
            if (ImGui::SliderFloat("Линейное затухание", &linearDamping, 0.0f, 1.0f)) {
                rbComponent->SetLinearDamping(linearDamping);
                MarkDirty();
            }
            
            float angularDamping = rbComponent->GetAngularDamping();
            if (ImGui::SliderFloat("Угловое затухание", &angularDamping, 0.0f, 1.0f)) {
                rbComponent->SetAngularDamping(angularDamping);
                MarkDirty();
            }
        }
    };
    
    // Регистрация инспектора для компонента коллайдера
    class ColliderInspector : public Wudgine::Editor::ComponentInspector {
    public:
        bool CanInspect(Wudgine::ECS::Component* component) override {
            return dynamic_cast<ColliderComponent*>(component) != nullptr;
        }
        
        void Render(Wudgine::ECS::Component* component) override {
            auto* colliderComponent = static_cast<ColliderComponent*>(component);
            
            // Отрисовка полей компонента
            const char* colliderTypes[] = { "Box", "Sphere", "Capsule", "Mesh" };
            int currentType = static_cast<int>(colliderComponent->GetColliderType());
            
            if (ImGui::Combo("Тип коллайдера", &currentType, colliderTypes, IM_ARRAYSIZE(colliderTypes))) {
                colliderComponent->SetColliderType(static_cast<ColliderComponent::ColliderType>(currentType));
                MarkDirty();
            }
            
            // Отображение параметров в зависимости от типа коллайдера
            switch (colliderComponent->GetColliderType()) {
                case ColliderComponent::ColliderType::Box: {
                    auto size = colliderComponent->GetBoxSize();
                    if (ImGui::DragFloat3("Размер", &size.x, 0.1f, 0.01f, 100.0f)) {
                        colliderComponent->SetBoxSize(size);
                        MarkDirty();
                    }
                    break;
                }
                case ColliderComponent::ColliderType::Sphere: {
                    float radius = colliderComponent->GetSphereRadius();
                    if (ImGui::DragFloat("Радиус", &radius, 0.1f, 0.01f, 100.0f)) {
                        colliderComponent->SetSphereRadius(radius);
                        MarkDirty();
                    }
                    break;
                }
                case ColliderComponent::ColliderType::Capsule: {
                    float radius = colliderComponent->GetCapsuleRadius();
                    float height = colliderComponent->GetCapsuleHeight();
                    
                    if (ImGui::DragFloat("Радиус", &radius, 0.1f, 0.01f, 100.0f)) {
                        colliderComponent->SetCapsuleRadius(radius);
                        MarkDirty();
                    }
                    
                    if (ImGui::DragFloat("Высота", &height, 0.1f, 0.01f, 100.0f)) {
                        colliderComponent->SetCapsuleHeight(height);
                        MarkDirty();
                    }
                    break;
                }
                case ColliderComponent::ColliderType::Mesh: {
                    std::string meshPath = colliderComponent->GetMeshPath();
                    char buffer[256];
                    strcpy(buffer, meshPath.c_str());
                    
                    if (ImGui::InputText("Путь к меш", buffer, sizeof(buffer))) {
                        colliderComponent->SetMeshPath(buffer);
                        MarkDirty();
                    }
                    
                    if (ImGui::Button("Обзор...")) {
                        // Открытие диалога выбора файла
                        // ...
                    }
                    break;
                }
            }
            
            float friction = colliderComponent->GetFriction();
            if (ImGui::SliderFloat("Трение", &friction, 0.0f, 1.0f)) {
                colliderComponent->SetFriction(friction);
                MarkDirty();
            }
            
            float restitution = colliderComponent->GetRestitution();
            if (ImGui::SliderFloat("Упругость", &restitution, 0.0f, 1.0f)) {
                colliderComponent->SetRestitution(restitution);
                MarkDirty();
            }
        }
    };
    
    Wudgine::Editor::InspectorManager::GetInstance().RegisterInspector(new RigidBodyInspector());
    Wudgine::Editor::InspectorManager::GetInstance().RegisterInspector(new ColliderInspector());
}

void PhysicsPlugin::RenderSettings() {
    ImGui::DragFloat("Гравитация", &m_settings.gravity, 0.1f, -20.0f, 20.0f);
    ImGui::SliderInt("Итерации решателя", &m_settings.solverIterations, 1, 20);
    ImGui::Checkbox("Непрерывное обнаружение столкновений", &m_settings.enableContinuousDetection);
    
    // Применение изменений
    PhysicsSystem::GetInstance().SetGravity(m_settings.gravity);
    PhysicsSystem::GetInstance().SetSolverIterations(m_settings.solverIterations);
    PhysicsSystem::GetInstance().SetContinuousDetection(m_settings.enableContinuousDetection);
    
    // Сохранение настроек
    Wudgine::Core::SettingsManager::GetInstance().SavePluginSettings(GetName(), m_settings);
}

// Экспорт плагина
extern "C" {
    WUDGINE_PLUGIN_API Wudgine::Plugin::IPlugin* CreatePlugin() {
        return new PhysicsPlugin();
    }
}
```

## Плагин для интеграции с внешним инструментом

Этот пример демонстрирует создание плагина для интеграции с внешним инструментом:

### Структура плагина

```
ExternalToolPlugin/
├── CMakeLists.txt
├── plugin.json
├── src/
│   ├── ExternalToolPlugin.h
│   ├── ExternalToolPlugin.cpp
│   ├── Tools/
│   │   ├── ExternalToolIntegration.h
│   │   └── ExternalToolIntegration.cpp
│   └── Editor/
│       ├── ExternalToolWindow.h
│       └── ExternalToolWindow.cpp
└── resources/
    └── icons/
        └── external_tool.png
```

### Файл манифеста

```json
{
  "name": "ExternalToolPlugin",
  "version": "1.0.0",
  "author": "Wudgine Team",
  "description": "Плагин для интеграции с внешним инструментом",
  "engineVersion": "1.0.0",
  "dependencies": [],
  "entryPoint": "ExternalToolPlugin"
}
```

### Основной класс плагина

```cpp
// ExternalToolPlugin.h
#pragma once

#include <Wudgine/Plugin/IPlugin.h>
#include "Tools/ExternalToolIntegration.h"

class ExternalToolPlugin : public Wudgine::Plugin::IPlugin {
public:
    ExternalToolPlugin();
    ~ExternalToolPlugin();

    // Реализация интерфейса IPlugin
    bool Initialize() override;
    void Shutdown() override;
    
    const char* GetName() const override { return "ExternalToolPlugin"; }
    const char* GetVersion() const override { return "1.0.0"; }
    const char* GetAuthor() const override { return "Wudgine Team"; }
    const char* GetDescription() const override { return "Плагин для интеграции с внешним инструментом"; }
    
    // Настройки плагина
    void RenderSettings() override;
    
    // Доступ к интеграции
    ExternalToolIntegration* GetIntegration() { return m_integration.get(); }

private:
    // Регистрация инструментов редактора
    void RegisterEditorTools();
    
    // Настройки плагина
    struct Settings {
        std::string externalToolPath;
        bool autoSync = true;
        int syncInterval = 5; // в секундах
        
        template<typename Archive>
        void serialize(Archive& ar) {
            ar & externalToolPath;
            ar & autoSync;
            ar & syncInterval;
        }
    };
    
    Settings m_settings;
    std::unique_ptr<ExternalToolIntegration> m_integration;
};
```

```cpp
// ExternalToolPlugin.cpp
#include "ExternalToolPlugin.h"
#include "Editor/ExternalToolWindow.h"

#include <Wudgine/Core/Log.h>
#include <Wudgine/Core/SettingsManager.h>
#include <Wudgine/Editor/EditorToolManager.h>
#include <Wudgine/Editor/EditorMenuManager.h>
#include <imgui.h>

ExternalToolPlugin::ExternalToolPlugin() = default;
ExternalToolPlugin::~ExternalToolPlugin() = default;

bool ExternalToolPlugin::Initialize() {
    WG_LOG_INFO("[ExternalToolPlugin] Инициализация...");
    
    // Загрузка настроек
    if (Wudgine::Core::SettingsManager::GetInstance().HasPluginSettings(GetName())) {
        m_settings = Wudgine::Core::SettingsManager::GetInstance().LoadPluginSettings<Settings>(GetName());
    }
    
    // Создание интеграции с внешним инструментом
    m_integration = std::make_unique<ExternalToolIntegration>(m_settings.externalToolPath);
    
    // Настройка интеграции
    m_integration->SetAutoSync(m_settings.autoSync);
    m_integration->SetSyncInterval(m_settings.syncInterval);
    
    // Регистрация инструментов редактора (если в режиме редактора)
    if (Wudgine::Core::IsEditor()) {
        RegisterEditorTools();
    }
    
    // Инициализация интеграции
    if (!m_integration->Initialize()) {
        WG_LOG_ERROR("[ExternalToolPlugin] Ошибка инициализации интеграции с внешним инструментом");
        return false;
    }
    
    WG_LOG_INFO("[ExternalToolPlugin] Инициализация завершена");
    return true;
}

void ExternalToolPlugin::Shutdown() {
    WG_LOG_INFO("[ExternalToolPlugin] Завершение работы...");
    
    // Сохранение настроек
    Wudgine::Core::SettingsManager::GetInstance().SavePluginSettings(GetName(), m_settings);
    
    // Завершение работы интеграции
    if (m_integration) {
        m_integration->Shutdown();
    }
    
    WG_LOG_INFO("[ExternalToolPlugin] Завершение работы завершено");
}

void ExternalToolPlugin::RegisterEditorTools() {
    // Регистрация окна внешнего инструмента
    auto* window = new ExternalToolWindow(m_integration.get());
    Wudgine::Editor::EditorToolManager::GetInstance().RegisterTool(window);
    
    // Добавление пунктов меню
    Wudgine::Editor::EditorMenuManager::GetInstance().AddMenuItem(
        "Инструменты/Внешний инструмент/Открыть",
        [window]() {
            window->SetVisible(true);
        }
    );
    
    Wudgine::Editor::EditorMenuManager::GetInstance().AddMenuItem(
        "Инструменты/Внешний инструмент/Синхронизировать",
        [this]() {
            m_integration->SyncNow();
        }
    );
    
    Wudgine::Editor::EditorMenuManager::GetInstance().AddMenuItem(
        "Инструменты/Внешний инструмент/Запустить внешний инструмент",
        [this]() {
            m_integration->LaunchExternalTool();
        }
    );
}

void ExternalToolPlugin::RenderSettings() {
    char buffer[256];
    strcpy(buffer, m_settings.externalToolPath.c_str());
    
    if (ImGui::InputText("Путь к внешнему инструменту", buffer, sizeof(buffer))) {
        m_settings.externalToolPath = buffer;
        m_integration->SetExternalToolPath(m_settings.externalToolPath);
    }
    
    if (ImGui::Button("Обзор...")) {
        // Открытие диалога выбора файла
        // ...
    }
    
    if (ImGui::Checkbox("Автоматическая синхронизация", &m_settings.autoSync)) {
        m_integration->SetAutoSync(m_settings.autoSync);
    }
    
    if (m_settings.autoSync) {
        if (ImGui::SliderInt("Интервал синхронизации (сек)", &m_settings.syncInterval, 1, 60)) {
            m_integration->SetSyncInterval(m_settings.syncInterval);
        }
    }
    
    if (ImGui::Button("Проверить соединение")) {
        bool connected = m_integration->TestConnection();
        if (connected) {
            WG_LOG_INFO("[ExternalToolPlugin] Соединение с внешним инструментом установлено");
        } else {
            WG_LOG_ERROR("[ExternalToolPlugin] Ошибка соединения с внешним инструментом");
        }
    }
    
    // Сохранение настроек
    Wudgine::Core::SettingsManager::GetInstance().SavePluginSettings(GetName(), m_settings);
}

// Экспорт плагина
extern "C" {
    WUDGINE_PLUGIN_API Wudgine::Plugin::IPlugin* CreatePlugin() {
        return new ExternalToolPlugin();
    }
}
```

## Что дальше?

Теперь, когда вы ознакомились с примерами плагинов, вы можете:

- Узнать, как [публиковать свои плагины](/ru/plugins/publishing-plugins)
- Изучить [продвинутые темы](/ru/advanced-topics/overview) для более глубокого понимания Wudgine

::alert{type="success"}
Экспериментируйте с плагинами и создавайте уникальные расширения для Wudgine, которые помогут вам в разработке игр!
::