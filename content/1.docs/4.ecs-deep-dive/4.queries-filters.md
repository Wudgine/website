::callout{type="info"}
В этом разделе описываются запросы и фильтры в системе ECS Wudgine, которые позволяют эффективно находить и обрабатывать сущности с определенными наборами компонентов.
::

## Основы запросов

Запросы в Wudgine позволяют системам находить сущности с определенными наборами компонентов. Это основной механизм для эффективной обработки данных в ECS.

### Создание запросов

```cpp
// Создание простого запроса
EntityQuery query = world.createQuery()
    .with<TransformComponent>()
    .with<MeshRendererComponent>()
    .build();

// Использование запроса
query.forEach([](Entity entity, TransformComponent& transform, MeshRendererComponent& renderer) {
    // Обработка каждой сущности с компонентами Transform и MeshRenderer
});
```

### Типы запросов

::list{type="primary"}
- **Включающие запросы**: Сущности должны иметь все указанные компоненты
- **Исключающие запросы**: Сущности не должны иметь указанные компоненты
- **Опциональные запросы**: Компоненты могут присутствовать или отсутствовать
- **Комбинированные запросы**: Сочетание включающих, исключающих и опциональных условий
::

```cpp
// Комбинированный запрос
EntityQuery query = world.createQuery()
    .with<TransformComponent>()        // Обязательный компонент
    .with<RigidbodyComponent>()        // Обязательный компонент
    .without<StaticComponent>()        // Исключающий компонент
    .optional<ColliderComponent>()     // Опциональный компонент
    .build();

// Использование запроса с опциональным компонентом
query.forEach([](Entity entity, 
                TransformComponent& transform, 
                RigidbodyComponent& rigidbody,
                OptionalComponent<ColliderComponent> collider) {
    // Проверка наличия опционального компонента
    if (collider) {
        // Использование компонента коллайдера
        auto& colliderComponent = collider.get();
        // ...
    } else {
        // Обработка случая отсутствия коллайдера
        // ...
    }
});
```

## Фильтры

Фильтры позволяют дополнительно ограничить результаты запросов на основе значений компонентов или других критериев.

### Фильтры по значениям компонентов

```cpp
// Запрос с фильтром по значению компонента
EntityQuery query = world.createQuery()
    .with<TransformComponent>()
    .with<HealthComponent>()
    .where<HealthComponent>([](const HealthComponent& health) {
        // Только сущности с здоровьем ниже 50%
        return health.currentHealth < health.maxHealth * 0.5f;
    })
    .build();

// Использование запроса с фильтром
query.forEach([](Entity entity, TransformComponent& transform, HealthComponent& health) {
    // Обработка сущностей с низким здоровьем
});
```

### Комбинированные фильтры

```cpp
// Запрос с несколькими фильтрами
EntityQuery query = world.createQuery()
    .with<TransformComponent>()
    .with<AIComponent>()
    .with<HealthComponent>()
    .where<AIComponent, TransformComponent>([](const AIComponent& ai, const TransformComponent& transform) {
        // Только активные AI в определенной зоне
        return ai.isActive && transform.position.y < 10.0f;
    })
    .where<HealthComponent>([](const HealthComponent& health) {
        // Только с здоровьем выше нуля
        return health.currentHealth > 0.0f;
    })
    .build();
```

### Фильтры по тегам и слоям

```cpp
// Запрос с фильтром по тегам
EntityQuery query = world.createQuery()
    .with<TransformComponent>()
    .withTag("Enemy")
    .withoutTag("Boss")
    .build();

// Запрос с фильтром по слоям
EntityQuery query = world.createQuery()
    .with<TransformComponent>()
    .with<ColliderComponent>()
    .inLayer(PhysicsLayer::Enemies)
    .notInLayer(PhysicsLayer::Triggers)
    .build();
```

## Эффективное использование запросов

### Кэширование запросов

```cpp
class EnemySystem : public ISystem {
private:
    World* m_world;
    EntityQuery m_activeEnemiesQuery;
    EntityQuery m_inactiveEnemiesQuery;

public:
    EnemySystem(World* world) : m_world(world) {
        // Кэширование запросов при инициализации
        m_activeEnemiesQuery = m_world->createQuery()
            .with<EnemyComponent>()
            .with<TransformComponent>()
            .where<EnemyComponent>([](const EnemyComponent& enemy) {
                return enemy.isActive;
            })
            .build();
            
        m_inactiveEnemiesQuery = m_world->createQuery()
            .with<EnemyComponent>()
            .with<TransformComponent>()
            .where<EnemyComponent>([](const EnemyComponent& enemy) {
                return !enemy.isActive;
            })
            .build();
    }

    void update(float deltaTime) override {
        // Использование кэшированных запросов
        updateActiveEnemies(deltaTime);
        activateInactiveEnemies();
    }

private:
    void updateActiveEnemies(float deltaTime) {
        m_activeEnemiesQuery.forEach([deltaTime](Entity entity, 
                                               EnemyComponent& enemy, 
                                               TransformComponent& transform) {
            // Обновление активных врагов
            // ...
        });
    }
    
    void activateInactiveEnemies() {
        // Активация неактивных врагов при необходимости
        // ...
    }
};
```

### Архетипы и чанки

Wudgine использует архетипы и чанки для оптимизации хранения и доступа к компонентам:

```cpp
// Создание архетипа
EntityArchetype characterArchetype = world.createArchetype()
    .with<TransformComponent>()
    .with<CharacterControllerComponent>()
    .with<AnimatorComponent>()
    .with<HealthComponent>()
    .build();

// Создание сущностей на основе архетипа
Entity player = world.createEntity(characterArchetype);
player.setName("Player");

// Создание множества сущностей одного архетипа
std::vector<Entity> enemies = world.createEntities(characterArchetype, 100);
```

### Итерация по чанкам

```cpp
// Запрос с итерацией по чанкам для оптимизации кэша
EntityQuery query = world.createQuery()
    .with<TransformComponent>()
    .with<VelocityComponent>()
    .build();

// Итерация по чанкам
query.forEachChunk([deltaTime](EntityChunk chunk, 
                             ComponentArray<TransformComponent> transforms, 
                             ComponentArray<VelocityComponent> velocities) {
    // Обработка всех сущностей в чанке за один проход
    for (size_t i = 0; i < chunk.size(); ++i) {
        transforms[i].position += velocities[i].value * deltaTime;
    }
});
```

## Продвинутые запросы

### Запросы с сортировкой

```cpp
// Запрос с сортировкой результатов
EntityQuery query = world.createQuery()
    .with<TransformComponent>()
    .with<HealthComponent>()
    .build();

// Получение отсортированных результатов
auto entities = query.getEntities();
std::sort(entities.begin(), entities.end(), [&world](Entity a, Entity b) {
    // Сортировка по расстоянию до игрока
    const auto& transformA = a.getComponent<TransformComponent>();
    const auto& transformB = b.getComponent<TransformComponent>();
    
    Entity player = world.findEntityByName("Player");
    Vector3 playerPos = player.getComponent<TransformComponent>().position;
    
    float distA = Vector3::distance(transformA.position, playerPos);
    float distB = Vector3::distance(transformB.position, playerPos);
    
    return distA < distB;
});

// Обработка отсортированных сущностей
for (auto entity : entities) {
    // Обработка сущностей в порядке близости к игроку
    // ...
}
```

### Запросы с пагинацией

```cpp
// Запрос с пагинацией для обработки больших наборов данных
EntityQuery query = world.createQuery()
    .with<AIComponent>()
    .with<TransformComponent>()
    .build();

// Параметры пагинации
size_t pageSize = 50;
size_t totalEntities = query.count();
size_t pageCount = (totalEntities + pageSize - 1) / pageSize;

// Обработка сущностей постранично
for (size_t page = 0; page < pageCount; ++page) {
    size_t offset = page * pageSize;
    size_t limit = std::min(pageSize, totalEntities - offset);
    
    query.forEachSlice(offset, limit, [](Entity entity, 
                                        AIComponent& ai, 
                                        TransformComponent& transform) {
        // Обработка сущностей на текущей странице
        // ...
    });
}
```

### Запросы с группировкой

```cpp
// Запрос с группировкой результатов
EntityQuery query = world.createQuery()
    .with<TransformComponent>()
    .with<TeamComponent>()
    .build();

// Группировка сущностей по командам
std::unordered_map<int, std::vector<Entity>> teamGroups;

query.forEach([&teamGroups](Entity entity, 
                           TransformComponent& transform, 
                           TeamComponent& team) {
    // Группировка по ID команды
    teamGroups[team.teamId].push_back(entity);
});

// Обработка сгруппированных сущностей
for (auto& [teamId, entities] : teamGroups) {
    // Обработка всех сущностей в команде
    // ...
}
```

## Динамические запросы

### Изменение запросов во время выполнения

```cpp
// Создание динамического запроса
DynamicEntityQuery dynamicQuery = world.createDynamicQuery();

// Настройка запроса во время выполнения
void configureQuery(bool includeEnemies, bool includeBosses, float minHealth) {
    // Сброс предыдущих условий
    dynamicQuery.reset();
    
    // Базовые компоненты
    dynamicQuery.with<TransformComponent>();
    dynamicQuery.with<HealthComponent>();
    
    // Динамические условия
    if (includeEnemies) {
        dynamicQuery.withTag("Enemy");
    }
    
    if (!includeBosses) {
        dynamicQuery.withoutTag("Boss");
    }
    
    // Динамический фильтр
    dynamicQuery.where<HealthComponent>([minHealth](const HealthComponent& health) {
        return health.currentHealth >= minHealth;
    });
    
    // Применение изменений
    dynamicQuery.apply();
}

// Использование динамического запроса
void processEntities() {
    dynamicQuery.forEach([](Entity entity, 
                          TransformComponent& transform, 
                          HealthComponent& health) {
        // Обработка сущностей
        // ...
    });
}
```

### Запросы с обратными вызовами при изменениях

```cpp
// Запрос с отслеживанием изменений
EntityQuery query = world.createQuery()
    .with<PlayerComponent>()
    .with<HealthComponent>()
    .trackChanges()
    .build();

// Регистрация обратных вызовов для отслеживания изменений
query.onEntityAdded([](Entity entity) {
    Debug::log("Entity added to query: {}", entity.getName());
});

query.onEntityRemoved([](Entity entity) {
    Debug::log("Entity removed from query: {}", entity.getName());
});

query.onComponentChanged<HealthComponent>([](Entity entity, 
                                           const HealthComponent& oldValue, 
                                           const HealthComponent& newValue) {
    float healthDiff = newValue.currentHealth - oldValue.currentHealth;
    if (healthDiff < 0) {
        Debug::log("Entity {} took {} damage", entity.getName(), -healthDiff);
    } else if (healthDiff > 0) {
        Debug::log("Entity {} healed for {}", entity.getName(), healthDiff);
    }
});
```

## Следующие шаги

Теперь, когда вы ознакомились с запросами и фильтрами в Wudgine, рекомендуем:

::card-group
  :::card{icon="i-lucide-globe" title="Веб-интерфейсы" to="/ru/5.web-interfaces/1.overview"}
  Изучите, как интегрировать веб-технологии в ваши игры.
  :::
  :::card{icon="i-lucide-puzzle" title="Плагины" to="/ru/6.plugins/1.overview"}
  Узнайте, как расширить функциональность движка с помощью плагинов.
  :::
::