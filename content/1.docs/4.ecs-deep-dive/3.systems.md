::callout{type="info"}
В этом разделе описываются системы в архитектуре ECS Wudgine, которые обрабатывают компоненты и реализуют игровую логику.
::

## Основы систем

Системы в Wudgine — это классы, которые обрабатывают данные компонентов и реализуют игровую логику. Они работают с группами сущностей, имеющих определенные наборы компонентов.

### Создание системы

```cpp
// Базовый класс системы
class ISystem {
public:
    virtual ~ISystem() = default;
    virtual void initialize() {}
    virtual void update(float deltaTime) {}
    virtual void lateUpdate(float deltaTime) {}
    virtual void fixedUpdate(float fixedDeltaTime) {}
    virtual void cleanup() {}
};

// Пример пользовательской системы
class MovementSystem : public ISystem {
private:
    World* m_world;
    EntityQuery m_query;

public:
    MovementSystem(World* world) : m_world(world) {
        // Создание запроса для сущностей с нужными компонентами
        m_query = m_world->createQuery()
            .with<TransformComponent>()
            .with<VelocityComponent>()
            .build();
    }

    void update(float deltaTime) override {
        // Обработка всех сущностей, соответствующих запросу
        m_query.forEach([deltaTime](Entity entity, 
                                   TransformComponent& transform, 
                                   VelocityComponent& velocity) {
            // Обновление позиции на основе скорости
            transform.position += velocity.value * deltaTime;
        });
    }
};

// Регистрация системы в мире
world.addSystem<MovementSystem>();
```

### Жизненный цикл системы

Системы имеют следующие методы жизненного цикла:

::list{type="primary"}
- **initialize()**: Вызывается один раз при инициализации системы
- **update(deltaTime)**: Вызывается каждый кадр для обновления логики
- **lateUpdate(deltaTime)**: Вызывается после update всех систем
- **fixedUpdate(fixedDeltaTime)**: Вызывается с фиксированным временным шагом для физики
- **cleanup()**: Вызывается при уничтожении системы
::

## Типы систем

### Системы обновления (Update Systems)

Выполняются каждый кадр и обрабатывают основную игровую логику:

```cpp
class AISystem : public ISystem {
private:
    World* m_world;
    EntityQuery m_query;

public:
    AISystem(World* world) : m_world(world) {
        m_query = m_world->createQuery()
            .with<AIComponent>()
            .with<TransformComponent>()
            .build();
    }

    void update(float deltaTime) override {
        m_query.forEach([this, deltaTime](Entity entity, 
                                         AIComponent& ai, 
                                         TransformComponent& transform) {
            // Поиск ближайшей цели
            Entity target = findNearestTarget(entity, transform.position);
            if (target.isValid()) {
                ai.target = target;
                // Обновление поведения ИИ
                updateBehavior(entity, ai, transform, target, deltaTime);
            }
        });
    }

private:
    Entity findNearestTarget(Entity self, const Vector3& position) {
        // Реализация поиска ближайшей цели
        // ...
        return Entity();
    }

    void updateBehavior(Entity entity, AIComponent& ai, 
                       TransformComponent& transform, 
                       Entity target, float deltaTime) {
        // Реализация поведения ИИ
        // ...
    }
};
```

### Системы физики (Physics Systems)

Выполняются с фиксированным временным шагом для стабильной симуляции физики:

```cpp
class PhysicsSystem : public ISystem {
private:
    World* m_world;
    EntityQuery m_query;
    PhysicsWorld m_physicsWorld;

public:
    PhysicsSystem(World* world) : m_world(world) {
        m_query = m_world->createQuery()
            .with<RigidbodyComponent>()
            .with<TransformComponent>()
            .build();
            
        // Инициализация физического мира
        m_physicsWorld.initialize();
    }

    void fixedUpdate(float fixedDeltaTime) override {
        // Синхронизация трансформаций с физическим миром
        syncTransformsToPhysics();
        
        // Выполнение шага физической симуляции
        m_physicsWorld.step(fixedDeltaTime);
        
        // Синхронизация результатов физики с компонентами трансформации
        syncPhysicsToTransforms();
        
        // Обработка столкновений
        processCollisions();
    }

private:
    void syncTransformsToPhysics() {
        // Синхронизация позиций и поворотов из TransformComponent в физический мир
        // ...
    }
    
    void syncPhysicsToTransforms() {
        // Синхронизация результатов физической симуляции обратно в компоненты
        // ...
    }
    
    void processCollisions() {
        // Обработка произошедших столкновений
        // ...
    }
};
```

### Системы рендеринга (Rendering Systems)

Отвечают за сбор и отправку данных для рендеринга:

```cpp
class RenderSystem : public ISystem {
private:
    World* m_world;
    EntityQuery m_meshQuery;
    EntityQuery m_cameraQuery;
    RenderPipeline m_renderPipeline;

public:
    RenderSystem(World* world) : m_world(world) {
        m_meshQuery = m_world->createQuery()
            .with<MeshRendererComponent>()
            .with<TransformComponent>()
            .build();
            
        m_cameraQuery = m_world->createQuery()
            .with<CameraComponent>()
            .with<TransformComponent>()
            .build();
            
        // Инициализация конвейера рендеринга
        m_renderPipeline.initialize();
    }

    void lateUpdate(float deltaTime) override {
        // Поиск активной камеры
        Entity mainCamera = findMainCamera();
        if (!mainCamera.isValid()) return;
        
        // Сбор данных для рендеринга
        std::vector<RenderObject> renderObjects;
        collectRenderObjects(renderObjects);
        
        // Выполнение рендеринга
        m_renderPipeline.render(mainCamera, renderObjects);
    }

private:
    Entity findMainCamera() {
        // Поиск основной камеры
        Entity result;
        int highestPriority = -1;
        
        m_cameraQuery.forEach([&](Entity entity, CameraComponent& camera, TransformComponent& transform) {
            if (camera.isActive() && camera.getPriority() > highestPriority) {
                highestPriority = camera.getPriority();
                result = entity;
            }
        });
        
        return result;
    }
    
    void collectRenderObjects(std::vector<RenderObject>& renderObjects) {
        // Сбор объектов для рендеринга
        m_meshQuery.forEach([&](Entity entity, MeshRendererComponent& renderer, TransformComponent& transform) {
            if (renderer.isVisible()) {
                RenderObject obj;
                obj.entity = entity;
                obj.mesh = renderer.getMesh();
                obj.material = renderer.getMaterial();
                obj.transform = transform.getWorldMatrix();
                obj.layer = renderer.getLayer();
                
                renderObjects.push_back(obj);
            }
        });
    }
};
```

### Системы пользовательского интерфейса (UI Systems)

Обрабатывают элементы пользовательского интерфейса:

```cpp
class UISystem : public ISystem {
private:
    World* m_world;
    EntityQuery m_uiQuery;
    UIManager m_uiManager;

public:
    UISystem(World* world) : m_world(world) {
        m_uiQuery = m_world->createQuery()
            .with<UIElementComponent>()
            .with<TransformComponent>()
            .build();
            
        // Инициализация менеджера UI
        m_uiManager.initialize();
    }

    void update(float deltaTime) override {
        // Обновление состояния UI элементов
        m_uiQuery.forEach([&](Entity entity, UIElementComponent& ui, TransformComponent& transform) {
            // Обновление позиции и состояния UI элемента
            ui.update(deltaTime);
        });
        
        // Обработка ввода для UI
        processUIInput();
    }
    
    void lateUpdate(float deltaTime) override {
        // Рендеринг UI после всей остальной сцены
        m_uiManager.render();
    }

private:
    void processUIInput() {
        // Обработка ввода для UI элементов
        // ...
    }
};
```

### Системы ввода (Input Systems)

Обрабатывают пользовательский ввод:

```cpp
class InputSystem : public ISystem {
private:
    World* m_world;
    InputManager m_inputManager;
    EventBus* m_eventBus;

public:
    InputSystem(World* world, EventBus* eventBus) 
        : m_world(world), m_eventBus(eventBus) {
        // Инициализация менеджера ввода
        m_inputManager.initialize();
        
        // Регистрация обработчиков ввода
        registerInputHandlers();
    }

    void update(float deltaTime) override {
        // Опрос устройств ввода
        m_inputManager.pollDevices();
        
        // Обработка нажатий клавиш
        processKeyboardInput();
        
        // Обработка ввода мыши
        processMouseInput();
        
        // Обработка ввода геймпада
        processGamepadInput();
    }

private:
    void registerInputHandlers() {
        // Регистрация обработчиков ввода
        m_inputManager.registerKeyCallback(KeyCode::W, [this](bool pressed) {
            if (pressed) {
                m_eventBus->publish<MoveEvent>(Vector3(0, 0, 1));
            }
        });
        
        // Другие обработчики...
    }
    
    void processKeyboardInput() {
        // Обработка ввода с клавиатуры
        // ...
    }
    
    void processMouseInput() {
        // Обработка ввода мыши
        // ...
    }
    
    void processGamepadInput() {
        // Обработка ввода геймпада
        // ...
    }
};
```

## Приоритеты и зависимости систем

### Установка приоритетов

```cpp
// Регистрация систем с приоритетами
world.addSystem<InputSystem>(100);       // Высокий приоритет, выполняется первой
world.addSystem<AISystem>(50);           // Средний приоритет
world.addSystem<MovementSystem>(30);     // Низкий приоритет
world.addSystem<PhysicsSystem>(20);      // Очень низкий приоритет
world.addSystem<RenderSystem>(-100);     // Отрицательный приоритет, выполняется последней
```

### Зависимости между системами

```cpp
// Определение системы с зависимостями
class CombatSystem : public ISystem {
private:
    World* m_world;
    HealthSystem* m_healthSystem;
    AnimationSystem* m_animationSystem;

public:
    CombatSystem(World* world) : m_world(world) {
        // Получение зависимых систем
        m_healthSystem = m_world->getSystem<HealthSystem>();
        m_animationSystem = m_world->getSystem<AnimationSystem>();
        
        if (!m_healthSystem || !m_animationSystem) {
            Debug::logError("CombatSystem requires HealthSystem and AnimationSystem");
        }
    }

    void update(float deltaTime) override {
        // Использование других систем
        // ...
    }
};

// Регистрация систем в правильном порядке
world.addSystem<HealthSystem>();
world.addSystem<AnimationSystem>();
world.addSystem<CombatSystem>();
```

## Оптимизация систем

### Параллельное выполнение

```cpp
class ParticleSystem : public ISystem {
private:
    World* m_world;
    EntityQuery m_query;
    ThreadPool m_threadPool;

public:
    ParticleSystem(World* world) : m_world(world) {
        m_query = m_world->createQuery()
            .with<ParticleComponent>()
            .with<TransformComponent>()
            .build();
            
        // Инициализация пула потоков
        m_threadPool.initialize(std::thread::hardware_concurrency());
    }

    void update(float deltaTime) override {
        // Получение всех сущностей с частицами
        auto entities = m_query.getEntities();
        size_t entityCount = entities.size();
        
        // Параллельная обработка частиц
        m_threadPool.parallelFor(0, entityCount, [&](size_t i) {
            Entity entity = entities[i];
            auto& particles = entity.getComponent<ParticleComponent>();
            auto& transform = entity.getComponent<TransformComponent>();
            
            // Обновление частиц
            updateParticles(particles, transform, deltaTime);
        });
    }

private:
    void updateParticles(ParticleComponent& particles, 
                        const TransformComponent& transform, 
                        float deltaTime) {
        // Обновление состояния частиц
        // ...
    }
};
```

### Кэширование данных

```cpp
class PathfindingSystem : public ISystem {
private:
    World* m_world;
    EntityQuery m_query;
    NavigationMesh m_navMesh;
    std::unordered_map<Entity, Path> m_pathCache;
    float m_cacheTimeout = 1.0f;

public:
    PathfindingSystem(World* world) : m_world(world) {
        m_query = m_world->createQuery()
            .with<AIComponent>()
            .with<TransformComponent>()
            .build();
            
        // Загрузка навигационной сетки
        m_navMesh.load("assets/navmesh/level1.navmesh");
    }

    void update(float deltaTime) override {
        // Обновление кэша путей
        updatePathCache(deltaTime);
        
        // Обработка запросов на поиск пути
        m_query.forEach([this](Entity entity, AIComponent& ai, TransformComponent& transform) {
            if (ai.needsPath && ai.target.isValid()) {
                // Поиск пути к цели
                Vector3 start = transform.position;
                Vector3 end = ai.target.getComponent<TransformComponent>().position;
                
                // Проверка кэша
                Path path;
                if (tryGetCachedPath(entity, start, end, path)) {
                    ai.currentPath = path;
                } else {
                    // Вычисление нового пути
                    path = m_navMesh.findPath(start, end);
                    ai.currentPath = path;
                    
                    // Сохранение в кэш
                    cachePath(entity, start, end, path);
                }
                
                ai.needsPath = false;
            }
        });
    }

private:
    void updatePathCache(float deltaTime) {
        // Обновление времени жизни кэшированных путей
        // ...
    }
    
    bool tryGetCachedPath(Entity entity, const Vector3& start, 
                         const Vector3& end, Path& outPath) {
        // Попытка получить путь из кэша
        // ...
        return false;
    }
    
    void cachePath(Entity entity, const Vector3& start, 
                  const Vector3& end, const Path& path) {
        // Сохранение пути в кэш
        // ...
    }
};
```

## Системные группы

```cpp
// Определение группы систем
class PhysicsSystemGroup : public SystemGroup {
public:
    PhysicsSystemGroup(World* world) : SystemGroup(world) {
        // Добавление систем в группу
        addSystem<CollisionDetectionSystem>();
        addSystem<RigidbodySystem>();
        addSystem<ConstraintSystem>();
        addSystem<PhysicsDebugSystem>();
    }
};

// Регистрация группы систем
world.addSystemGroup<PhysicsSystemGroup>();
```

## События и сообщения

```cpp
// Определение события
struct CollisionEvent {
    Entity entityA;
    Entity entityB;
    Vector3 contactPoint;
    Vector3 contactNormal;
    float impulse;
};

// Система, публикующая события
class CollisionSystem : public ISystem {
private:
    World* m_world;
    EventBus* m_eventBus;
    PhysicsWorld m_physicsWorld;

public:
    CollisionSystem(World* world, EventBus* eventBus) 
        : m_world(world), m_eventBus(eventBus) {
        // Инициализация физического мира
        m_physicsWorld.initialize();
        
        // Регистрация обратного вызова для столкновений
        m_physicsWorld.setCollisionCallback([this](const PhysicsContact& contact) {
            // Создание события столкновения
            CollisionEvent event;
            event.entityA = contact.bodyA->getUserData<Entity>();
            event.entityB = contact.bodyB->getUserData<Entity>();
            event.contactPoint = contact.point;
            event.contactNormal = contact.normal;
            event.impulse = contact.impulse;
            
            // Публикация события
            m_eventBus->publish<CollisionEvent>(event);
        });
    }

    void fixedUpdate(float fixedDeltaTime) override {
        // Выполнение шага физической симуляции
        m_physicsWorld.step(fixedDeltaTime);
    }
};

// Система, подписывающаяся на события
class DamageSystem : public ISystem {
private:
    World* m_world;
    EventBus* m_eventBus;
    EventSubscription m_collisionSubscription;

public:
    DamageSystem(World* world, EventBus* eventBus) 
        : m_world(world), m_eventBus(eventBus) {
        // Подписка на события столкновений
        m_collisionSubscription = m_eventBus->subscribe<CollisionEvent>(
            [this](const CollisionEvent& event) {
                // Обработка столкновения
                processCollision(event);
            }
        );
    }

    ~DamageSystem() {
        // Отписка от событий
        m_collisionSubscription.unsubscribe();
    }

private:
    void processCollision(const CollisionEvent& event) {
        // Проверка наличия компонентов здоровья и урона
        if (event.entityA.hasComponent<HealthComponent>() && 
            event.entityB.hasComponent<DamageComponent>()) {
            
            auto& health = event.entityA.getComponent<HealthComponent>();
            auto& damage = event.entityB.getComponent<DamageComponent>();
            
            // Применение урона
            float damageAmount = damage.value * event.impulse * 0.1f;
            health.currentHealth -= damageAmount;
            
            // Проверка смерти
            if (health.currentHealth <= 0) {
                // Публикация события смерти
                m_eventBus->publish<DeathEvent>({event.entityA, event.entityB});
            }
        }
    }
};
```

## Следующие шаги

Теперь, когда вы ознакомились с системами в Wudgine, рекомендуем:

::card-group
  :::card{icon="i-lucide-filter" title="Запросы и фильтры" to="/ru/4.ecs-deep-dive/4.queries-filters"}
  Изучите, как эффективно запрашивать сущности с определенными компонентами.
  :::
  :::card{icon="i-lucide-globe" title="Веб-интерфейсы" to="/ru/5.web-interfaces/1.overview"}
  Узнайте, как интегрировать веб-технологии в ваши игры.
  :::
::