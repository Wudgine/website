::callout{type="info"}
В этом разделе описываются компоненты в системе ECS Wudgine.
::

## Основы компонентов

Компоненты в Wudgine — это контейнеры данных, которые прикрепляются к сущностям. Они не содержат логики, только данные.

### Создание компонентов

```cpp
// Определение простого компонента
struct HealthComponent {
    float maxHealth = 100.0f;
    float currentHealth = 100.0f;
    
    // Опционально: сериализация
    template<typename Archive>
    void serialize(Archive& archive) {
        archive(maxHealth, currentHealth);
    }
};

// Регистрация компонента
world.registerComponent<HealthComponent>();

// Добавление компонента к сущности
Entity player = world.createEntity("Player");
auto& health = player.addComponent<HealthComponent>();
health.maxHealth = 200.0f;
health.currentHealth = 200.0f;
```

### Жизненный цикл компонентов

Компоненты имеют следующие события жизненного цикла:

::list{type="primary"}
- **OnCreate**: Вызывается при создании компонента
- **OnDestroy**: Вызывается перед уничтожением компонента
- **OnEnable**: Вызывается при включении компонента
- **OnDisable**: Вызывается при отключении компонента
::

```cpp
// Компонент с методами жизненного цикла
struct AIComponent {
    float detectionRadius = 10.0f;
    Entity target;
    
    void onCreate() {
        Debug::log("AI Component created");
    }
    
    void onDestroy() {
        Debug::log("AI Component destroyed");
    }
    
    void onEnable() {
        Debug::log("AI Component enabled");
    }
    
    void onDisable() {
        Debug::log("AI Component disabled");
    }
};
```

## Встроенные компоненты

### TransformComponent

Определяет положение, поворот и масштаб сущности в пространстве:

```cpp
// Использование TransformComponent
auto& transform = entity.addComponent<TransformComponent>();
transform.position = Vector3(0.0f, 1.0f, 0.0f);
transform.rotation = Quaternion::fromEuler(0.0f, 45.0f, 0.0f);
transform.scale = Vector3(1.0f, 1.0f, 1.0f);

// Преобразования
Vector3 forward = transform.getForward();
Vector3 right = transform.getRight();
Vector3 up = transform.getUp();

// Преобразование координат
Vector3 localPoint = Vector3(1.0f, 0.0f, 0.0f);
Vector3 worldPoint = transform.localToWorld(localPoint);
Vector3 backToLocal = transform.worldToLocal(worldPoint);
```

### HierarchyComponent

Создает иерархические отношения между сущностями:

```cpp
// Создание иерархии
Entity parent = world.createEntity("Parent");
Entity child = world.createEntity("Child");

// Установка родителя
child.setParent(parent);

// Получение дочерних сущностей
auto children = parent.getChildren();
for (auto& childEntity : children) {
    Debug::log("Child: {}", childEntity.getName());
}

// Обход иерархии
parent.traverseHierarchy([](Entity entity, int depth) {
    std::string indent(depth * 2, ' ');
    Debug::log("{}Entity: {}", indent, entity.getName());
    return true; // продолжить обход
});
```

### MeshRendererComponent

Отвечает за рендеринг 3D-моделей:

```cpp
// Добавление рендерера меша
auto& meshRenderer = entity.addComponent<MeshRendererComponent>();
meshRenderer.setMesh("assets/models/character.mesh");
meshRenderer.setMaterial("assets/materials/character.mat");

// Настройка свойств рендеринга
meshRenderer.setCastShadows(true);
meshRenderer.setReceiveShadows(true);
meshRenderer.setLayer(RenderLayer::Default);
meshRenderer.setVisible(true);
```

### CameraComponent

Определяет камеру для рендеринга сцены:

```cpp
// Создание камеры
auto& camera = entity.addComponent<CameraComponent>();
camera.setProjectionType(ProjectionType::Perspective);
camera.setFieldOfView(60.0f);
camera.setNearClip(0.1f);
camera.setFarClip(1000.0f);
camera.setPriority(0); // Основная камера

// Настройка постобработки
camera.enablePostProcessing(true);
camera.addPostProcessEffect<BloomEffect>();
```

### LightComponent

Базовый компонент для источников света:

```cpp
// Создание направленного света
Entity sun = world.createEntity("Sun");
auto& dirLight = sun.addComponent<DirectionalLightComponent>();
dirLight.setDirection(Vector3(-0.5f, -1.0f, -0.3f));
dirLight.setColor(Vector3(1.0f, 0.95f, 0.9f));
dirLight.setIntensity(5.0f);
dirLight.setCastShadows(true);

// Создание точечного света
Entity lamp = world.createEntity("Lamp");
auto& pointLight = lamp.addComponent<PointLightComponent>();
pointLight.setColor(Vector3(1.0f, 0.8f, 0.6f));
pointLight.setIntensity(2.0f);
pointLight.setRange(10.0f);
pointLight.setCastShadows(true);
```

### RigidbodyComponent

Добавляет физическое тело для симуляции физики:

```cpp
// Добавление физического тела
auto& rigidbody = entity.addComponent<RigidbodyComponent>();
rigidbody.setMass(10.0f);
rigidbody.setDrag(0.1f);
rigidbody.setAngularDrag(0.05f);
rigidbody.setUseGravity(true);
rigidbody.setKinematic(false);

// Применение сил
rigidbody.addForce(Vector3(0.0f, 0.0f, 10.0f));
rigidbody.addTorque(Vector3(0.0f, 1.0f, 0.0f));
```

### ColliderComponent

Определяет форму для физических столкновений:

::code-group
```cpp [BoxCollider]
// Создание коллайдера-коробки
auto& boxCollider = entity.addComponent<BoxColliderComponent>();
boxCollider.setSize(Vector3(1.0f, 1.0f, 1.0f));
boxCollider.setCenter(Vector3(0.0f, 0.5f, 0.0f));
boxCollider.setMaterial("assets/physics/metal.phymat");
```

```cpp [SphereCollider]
// Создание сферического коллайдера
auto& sphereCollider = entity.addComponent<SphereColliderComponent>();
sphereCollider.setRadius(0.5f);
sphereCollider.setCenter(Vector3(0.0f, 0.5f, 0.0f));
sphereCollider.setMaterial("assets/physics/rubber.phymat");
```

```cpp [MeshCollider]
// Создание меш-коллайдера
auto& meshCollider = entity.addComponent<MeshColliderComponent>();
meshCollider.setMesh("assets/models/terrain.mesh");
meshCollider.setConvex(false);
```
::

### AudioComponent

Компоненты для воспроизведения звуков:

```cpp
// Добавление источника звука
auto& audioSource = entity.addComponent<AudioSourceComponent>();
audioSource.setClip("assets/audio/explosion.wav");
audioSource.setVolume(0.8f);
audioSource.setPitch(1.0f);
audioSource.setLoop(false);
audioSource.setSpatialBlend(1.0f); // 3D звук
audioSource.setMinDistance(1.0f);
audioSource.setMaxDistance(20.0f);

// Воспроизведение звука
audioSource.play();
```

### AnimatorComponent

Управляет анимацией персонажей и объектов:

```cpp
// Добавление аниматора
auto& animator = entity.addComponent<AnimatorComponent>();
animator.setController("assets/animations/character.controller");

// Воспроизведение анимации
animator.play("Walk");

// Настройка параметров анимации
animator.setFloat("Speed", 1.5f);
animator.setBool("IsJumping", true);
animator.setTrigger("Attack");

// Смешивание анимаций
animator.crossFade("Run", 0.2f);
```

### WebUIComponent

Интегрирует веб-интерфейсы в игровые объекты:

```cpp
// Добавление веб-интерфейса
auto& webUI = entity.addComponent<WebUIComponent>();
webUI.setSource("assets/ui/inventory.html");
webUI.setSize(512, 512);
webUI.setTransparent(true);
webUI.setInteractive(true);

// Взаимодействие с JavaScript
webUI.callJavaScriptFunction("updateInventory", {{"gold", 100}, {"items", itemsArray}});

// Регистрация обратного вызова из JavaScript
webUI.registerCallback("onItemSelected", [](const json& args) {
    int itemId = args["itemId"];
    Debug::log("Item selected: {}", itemId);
});
```

## Пользовательские компоненты

### Создание компонентов с данными

```cpp
// Компонент здоровья с дополнительными функциями
struct HealthComponent {
    float maxHealth = 100.0f;
    float currentHealth = 100.0f;
    bool isInvulnerable = false;
    float regenerationRate = 0.0f;
    
    // Вспомогательные методы (не логика!)
    float getHealthPercentage() const {
        return currentHealth / maxHealth;
    }
    
    bool isDead() const {
        return currentHealth <= 0.0f;
    }
    
    // Сериализация
    template<typename Archive>
    void serialize(Archive& archive) {
        archive(maxHealth, currentHealth, isInvulnerable, regenerationRate);
    }
};
```

### Компоненты с событиями

```cpp
// Компонент с событиями
struct DamageableComponent {
    using DamageEvent = std::function<void(float damageAmount, Entity source)>;
    using DeathEvent = std::function<void(Entity killer)>;
    
    float armor = 0.0f;
    float damageMultiplier = 1.0f;
    
    DamageEvent onDamage;
    DeathEvent onDeath;
    
    // Сериализация (события не сериализуются)
    template<typename Archive>
    void serialize(Archive& archive) {
        archive(armor, damageMultiplier);
    }
};

// Использование событий компонента
auto& damageable = entity.addComponent<DamageableComponent>();
damageable.onDamage = [](float amount, Entity source) {
    Debug::log("Received {} damage from {}", amount, source.getName());
};
damageable.onDeath = [](Entity killer) {
    Debug::log("Killed by {}", killer.getName());
};
```

### Компоненты с зависимостями

```cpp
// Компонент, зависящий от других компонентов
struct HealthUIComponent {
    Entity healthBarEntity;
    float updateInterval = 0.1f;
    float lastUpdateTime = 0.0f;
    
    void onCreate() {
        // Проверка зависимостей
        if (!entity.hasComponent<HealthComponent>()) {
            Debug::logWarning("HealthUIComponent requires HealthComponent");
        }
    }
    
    // Сериализация
    template<typename Archive>
    void serialize(Archive& archive) {
        archive(healthBarEntity, updateInterval);
    }
};
```

## Рефлексия компонентов

Wudgine использует систему рефлексии для автоматической регистрации и сериализации компонентов:

```cpp
// Определение компонента с рефлексией
struct PlayerComponent {
    float moveSpeed = 5.0f;
    float jumpForce = 10.0f;
    int playerLevel = 1;
    std::string playerName = "Player";
    
    REFLECT_COMPONENT(PlayerComponent)
    
    static void registerReflection() {
        REFLECT_PROPERTY(moveSpeed, "Move Speed", "Speed at which the player moves")
            .setRange(1.0f, 20.0f)
            .setDefaultValue(5.0f);
            
        REFLECT_PROPERTY(jumpForce, "Jump Force", "Force applied when jumping")
            .setRange(5.0f, 30.0f);
            
        REFLECT_PROPERTY(playerLevel, "Level", "Current player level")
            .setRange(1, 100);
            
        REFLECT_PROPERTY(playerName, "Name", "Player's name");
    }
};

// Автоматическая регистрация
REGISTER_COMPONENT(PlayerComponent)
```

## Следующие шаги

Теперь, когда вы ознакомились с компонентами в Wudgine, рекомендуем:

::card-group
  :::card{icon="i-lucide-cog" title="Системы" to="/ru/4.ecs-deep-dive/3.systems"}
  Изучите системы, которые обрабатывают компоненты.
  :::
  :::card{icon="i-lucide-filter" title="Запросы и фильтры" to="/ru/4.ecs-deep-dive/4.queries-filters"}
  Узнайте, как эффективно запрашивать сущности с определенными компонентами.
  :::
::