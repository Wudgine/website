::alert{type="info"}
Сетевое взаимодействие в Wudgine позволяет создавать многопользовательские игры с синхронизированным игровым процессом и низкой задержкой.
::

## Введение в сетевое взаимодействие

Создание многопользовательских игр требует надежной и эффективной сетевой инфраструктуры. Wudgine предоставляет мощный набор инструментов для реализации различных типов сетевого взаимодействия, от простых пошаговых игр до сложных многопользовательских миров реального времени.

## Архитектура клиент-сервер

Wudgine использует классическую архитектуру клиент-сервер для многопользовательских игр, где сервер является авторитетным источником состояния игры.

### Основные компоненты

- **Сервер** — центральный узел, управляющий состоянием игры
- **Клиент** — подключается к серверу и отображает игровой мир
- **Сетевой менеджер** — управляет соединениями и передачей данных
- **Сериализация** — преобразование игровых объектов в данные для передачи

### Создание сервера

```cpp
#include "Wudgine/Networking/Server.hpp"

// Создание сервера
Wudgine::Networking::Server server;

// Настройка параметров
server.SetMaxClients(16);
server.SetTickRate(60); // 60 обновлений в секунду

// Обработчики событий
server.OnClientConnected([](Wudgine::Networking::ClientID clientID) {
    std::cout << "Клиент " << clientID << " подключился" << std::endl;
    
    // Отправка начального состояния игры
    SendInitialGameState(clientID);
});

// Запуск сервера
if (server.Start(27015)) {
    std::cout << "Сервер запущен на порту 27015" << std::endl;
}
```

### Создание клиента

```cpp
#include "Wudgine/Networking/Client.hpp"

// Создание клиента
Wudgine::Networking::Client client;

// Обработчики событий
client.OnConnected([]() {
    std::cout << "Подключение к серверу установлено" << std::endl;
});

// Подключение к серверу
if (client.Connect("127.0.0.1", 27015)) {
    std::cout << "Подключение к серверу..." << std::endl;
}
```

## Синхронизация состояния игры

Одна из ключевых задач в многопользовательских играх — синхронизация состояния игры между сервером и клиентами.

### Сериализация компонентов ECS

```cpp
// Сетевой компонент для синхронизации
struct NetworkTransformComponent : public Wudgine::ECS::Component, 
                                  public Wudgine::Core::Serializable {
    Wudgine::Math::Vector3 position;
    Wudgine::Math::Quaternion rotation;
    Wudgine::Math::Vector3 scale;
    
    // Метод сериализации для отправки по сети
    void Serialize(Wudgine::Core::ByteBuffer& buffer) const override {
        buffer.Write(position);
        buffer.Write(rotation);
        buffer.Write(scale);
    }
    
    // Метод десериализации для приема по сети
    void Deserialize(Wudgine::Core::ByteBuffer& buffer) override {
        buffer.Read(position);
        buffer.Read(rotation);
        buffer.Read(scale);
    }
};
```

## Предсказание и интерполяция

Для обеспечения плавного игрового процесса при наличии сетевых задержек Wudgine предоставляет механизмы предсказания и интерполяции.

### Предсказание на стороне клиента

```cpp
// Система предсказания движения
class MovementPredictionSystem : public Wudgine::ECS::System {
public:
    void Update(float deltaTime) override {
        auto view = GetWorld()->GetRegistry().view<NetworkTransformComponent, InputComponent>();
        
        view.each([deltaTime](auto entity, NetworkTransformComponent& transform, InputComponent& input) {
            // Применение локального ввода до получения подтверждения от сервера
            if (input.moveForward) {
                transform.position += transform.rotation * Wudgine::Math::Vector3::Forward() * MOVE_SPEED * deltaTime;
            }
            
            // Сохранение предсказанного состояния
            m_PredictedStates[entity].push_back({transform, GetWorld()->GetTime()});
        });
    }
};
```

## Обработка задержек и потерь пакетов

Wudgine предоставляет механизмы для обработки сетевых проблем, таких как задержки и потери пакетов.

### Надежная доставка

```cpp
// Отправка надежного сообщения
void SendReliableMessage(Wudgine::Networking::ClientID clientID, const GameEvent& event) {
    Wudgine::Core::ByteBuffer buffer;
    
    // Сериализация события
    buffer.Write(static_cast<uint8_t>(event.type));
    event.Serialize(buffer);
    
    // Отправка с гарантией доставки
    m_Server.SendReliable(clientID, buffer);
}
```

## Масштабирование серверной части

Для создания масштабируемых многопользовательских игр Wudgine предоставляет инструменты для распределения нагрузки.

### Зонирование мира

```cpp
// Менеджер зон
class ZoneManager {
public:
    // Инициализация зон
    void Initialize(const Wudgine::Math::Vector2& worldSize, const Wudgine::Math::Vector2& zoneSize) {
        m_WorldSize = worldSize;
        m_ZoneSize = zoneSize;
        
        // Вычисление количества зон
        int zonesX = static_cast<int>(std::ceil(worldSize.x / zoneSize.x));
        int zonesY = static_cast<int>(std::ceil(worldSize.y / zoneSize.y));
        
        // Создание зон
        m_Zones.resize(zonesX * zonesY);
    }
};
```

## Что дальше?

- Изучите [расширенную работу с ресурсами](/ru/advanced-topics/advanced-resources) для оптимизации загрузки и управления игровыми ресурсами
- Ознакомьтесь с [отладкой и профилированием](/ru/advanced-topics/debugging-profiling) для анализа производительности сетевого кода
- Исследуйте примеры многопользовательских игр в [репозитории примеров Wudgine](https://github.com/wudgine/examples)

::alert{type="warning"}
Разработка многопользовательских игр требует особого внимания к безопасности. Всегда проверяйте входящие данные на сервере и не доверяйте данным, полученным от клиентов.
::