::alert{type="info"}
Эффективное управление ресурсами критически важно для производительности игры. В этом разделе рассматриваются продвинутые техники работы с ресурсами в Wudgine.
::

## Введение

Управление ресурсами — один из ключевых аспектов разработки игр, особенно для проектов с большим количеством контента. Wudgine предоставляет расширенные возможности для оптимизации загрузки, хранения и использования игровых ресурсов.

## Асинхронная загрузка ресурсов

Асинхронная загрузка позволяет загружать ресурсы в фоновом режиме, не блокируя основной поток игры.

### Система асинхронной загрузки

```cpp
// Использование асинхронной загрузки текстур
Wudgine::Resources::TextureHandle textureHandle = 
    resourceManager.LoadTextureAsync("textures/large_terrain.png", 
                                    [](Wudgine::Resources::TextureHandle handle) {
    // Этот код выполнится после загрузки текстуры
    std::cout << "Текстура загружена!" << std::endl;
});

// Проверка статуса загрузки
if (resourceManager.IsLoading(textureHandle)) {
    // Ресурс все еще загружается
    float progress = resourceManager.GetLoadingProgress(textureHandle);
    std::cout << "Прогресс загрузки: " << progress * 100.0f << "%" << std::endl;
} else {
    // Ресурс загружен и готов к использованию
    auto texture = resourceManager.Get<Wudgine::Resources::Texture>(textureHandle);
}
```

### Группы загрузки

```cpp
// Создание группы загрузки
Wudgine::Resources::LoadGroup levelResources;

// Добавление ресурсов в группу
levelResources.AddTexture("textures/terrain.png");
levelResources.AddTexture("textures/buildings.png");
levelResources.AddModel("models/player.obj");
levelResources.AddSound("sounds/ambient.wav");

// Запуск асинхронной загрузки группы
resourceManager.LoadGroupAsync(levelResources, [](Wudgine::Resources::LoadGroup& group) {
    // Этот код выполнится после загрузки всех ресурсов группы
    std::cout << "Все ресурсы уровня загружены!" << std::endl;
});

// Отслеживание прогресса загрузки группы
float groupProgress = resourceManager.GetGroupLoadingProgress(levelResources);
```

## Потоковая загрузка

Потоковая загрузка позволяет загружать и выгружать ресурсы в реальном времени в зависимости от потребностей игры.

### Система потоковой загрузки

```cpp
// Настройка системы потоковой загрузки
Wudgine::Resources::StreamingSystem streamingSystem;
streamingSystem.SetMaxMemoryUsage(1024 * 1024 * 1024); // 1 ГБ
streamingSystem.SetLoadingBudgetPerFrame(5 * 1024 * 1024); // 5 МБ за кадр

// Регистрация обработчика для определения приоритета ресурсов
streamingSystem.SetPriorityHandler([](const Wudgine::Resources::ResourceInfo& resource) {
    // Вычисление приоритета на основе расстояния до камеры
    float distance = CalculateDistanceToCamera(resource.position);
    return 1.0f / (distance + 1.0f); // Чем ближе, тем выше приоритет
});

// Обновление системы потоковой загрузки каждый кадр
void Update(float deltaTime) {
    // Обновление позиции камеры
    streamingSystem.SetCameraPosition(camera.GetPosition());
    
    // Обработка загрузки/выгрузки ресурсов
    streamingSystem.Update(deltaTime);
}
```

### Уровни детализации (LOD)

```cpp
// Настройка LOD для модели
Wudgine::Resources::ModelHandle modelHandle = resourceManager.LoadModel("models/character.obj");
auto model = resourceManager.Get<Wudgine::Resources::Model>(modelHandle);

// Добавление уровней детализации
model->AddLOD(1, resourceManager.LoadModel("models/character_lod1.obj"));
model->AddLOD(2, resourceManager.LoadModel("models/character_lod2.obj"));
model->AddLOD(3, resourceManager.LoadModel("models/character_lod3.obj"));

// Настройка расстояний для переключения LOD
model->SetLODDistance(1, 10.0f);  // Переключение на LOD1 на расстоянии 10 единиц
model->SetLODDistance(2, 30.0f);  // Переключение на LOD2 на расстоянии 30 единиц
model->SetLODDistance(3, 100.0f); // Переключение на LOD3 на расстоянии 100 единиц
```

## Виртуальная текстурная память

Виртуальная текстурная память позволяет эффективно работать с текстурами, размер которых превышает доступную видеопамять.

### Настройка виртуальной текстурной памяти

```cpp
// Инициализация системы виртуальных текстур
Wudgine::Resources::VirtualTextureSystem vtSystem;
vtSystem.Initialize(4096, 4096); // Размер виртуальной текстуры 4096x4096
vtSystem.SetPageSize(128); // Размер страницы 128x128 пикселей
vtSystem.SetCacheSize(512 * 1024 * 1024); // Кэш 512 МБ

// Загрузка мегатекстуры
Wudgine::Resources::VirtualTextureHandle vtHandle = 
    vtSystem.LoadVirtualTexture("textures/terrain_mega.vtex");

// Использование виртуальной текстуры в шейдере
shader->SetVirtualTexture("terrainTexture", vtHandle);

// Обновление системы виртуальных текстур каждый кадр
void Update(float deltaTime) {
    // Обновление видимых областей
    vtSystem.UpdateVisibleRegions(camera);
    
    // Загрузка необходимых страниц
    vtSystem.UpdatePageCache();
}
```

## Сжатие ресурсов

Wudgine поддерживает различные форматы сжатия для оптимизации использования памяти.

### Сжатие текстур

```cpp
// Загрузка текстуры с указанием формата сжатия
Wudgine::Resources::TextureLoadOptions options;
options.compressionFormat = Wudgine::Resources::TextureCompressionFormat::BC7;
options.generateMipmaps = true;
options.mipmapFilter = Wudgine::Resources::MipmapFilter::Kaiser;

Wudgine::Resources::TextureHandle textureHandle = 
    resourceManager.LoadTexture("textures/albedo.png", options);
```

### Сжатие моделей

```cpp
// Загрузка модели с оптимизацией
Wudgine::Resources::ModelLoadOptions options;
options.optimizeMesh = true;
options.compressVertexData = true;
options.vertexCacheOptimization = true;

Wudgine::Resources::ModelHandle modelHandle = 
    resourceManager.LoadModel("models/complex_scene.obj", options);
```

## Горячая перезагрузка ресурсов

Горячая перезагрузка позволяет обновлять ресурсы без перезапуска игры, что ускоряет процесс разработки.

### Настройка горячей перезагрузки

```cpp
// Включение системы горячей перезагрузки
Wudgine::Resources::HotReloadSystem hotReloadSystem;
hotReloadSystem.Initialize(resourceManager);
hotReloadSystem.WatchDirectory("assets/textures");
hotReloadSystem.WatchDirectory("assets/models");
hotReloadSystem.WatchDirectory("assets/shaders");

// Регистрация обработчика событий
hotReloadSystem.OnResourceReloaded([](const std::string& path) {
    std::cout << "Ресурс перезагружен: " << path << std::endl;
});

// Обновление системы горячей перезагрузки
void Update(float deltaTime) {
    hotReloadSystem.Update();
}
```

## Пулы ресурсов

Пулы ресурсов позволяют эффективно управлять часто используемыми объектами.

### Создание и использование пула

```cpp
// Создание пула частиц
Wudgine::Resources::ResourcePool<Particle> particlePool(1000);

// Получение объекта из пула
Particle* particle = particlePool.Acquire();
if (particle) {
    // Инициализация частицы
    particle->position = position;
    particle->velocity = velocity;
    particle->lifetime = 2.0f;
    particle->color = color;
}

// Возврат объекта в пул
particlePool.Release(particle);

// Очистка неиспользуемых объектов
particlePool.GarbageCollect();
```

## Кэширование ресурсов

Кэширование позволяет ускорить доступ к часто используемым ресурсам.

### Настройка кэша ресурсов

```cpp
// Настройка кэша ресурсов
Wudgine::Resources::ResourceCache cache;
cache.SetMaxSize(1024 * 1024 * 512); // 512 МБ
cache.SetEvictionPolicy(Wudgine::Resources::EvictionPolicy::LRU);

// Добавление ресурса в кэш
cache.Add("textures/ui.png", textureHandle);

// Получение ресурса из кэша
if (cache.Contains("textures/ui.png")) {
    auto handle = cache.Get("textures/ui.png");
    auto texture = resourceManager.Get<Wudgine::Resources::Texture>(handle);
}

// Очистка кэша
cache.Clear();
```

## Предварительная обработка ресурсов

Wudgine поддерживает предварительную обработку ресурсов для оптимизации их использования в игре.

### Конвейер обработки ресурсов

```cpp
// Настройка конвейера обработки текстур
Wudgine::Resources::TextureProcessor textureProcessor;
textureProcessor.AddStep<Wudgine::Resources::ResizeStep>(2048, 2048);
textureProcessor.AddStep<Wudgine::Resources::NormalMapGeneratorStep>();
textureProcessor.AddStep<Wudgine::Resources::CompressionStep>(Wudgine::Resources::TextureCompressionFormat::BC5);

// Обработка текстуры
textureProcessor.Process("textures/input.png", "textures/output.dds");
```

## Управление памятью

Эффективное управление памятью критически важно для производительности игры.

### Отслеживание использования памяти

```cpp
// Получение информации об использовании памяти
Wudgine::Resources::MemoryStats memoryStats = resourceManager.GetMemoryStats();

std::cout << "Использование памяти:" << std::endl;
std::cout << "- Текстуры: " << memoryStats.textureMemory / (1024 * 1024) << " МБ" << std::endl;
std::cout << "- Модели: " << memoryStats.modelMemory / (1024 * 1024) << " МБ" << std::endl;
std::cout << "- Звуки: " << memoryStats.audioMemory / (1024 * 1024) << " МБ" << std::endl;
std::cout << "- Всего: " << memoryStats.totalMemory / (1024 * 1024) << " МБ" << std::endl;

// Установка ограничений памяти
resourceManager.SetMemoryLimit(Wudgine::Resources::ResourceType::Texture, 1024 * 1024 * 512); // 512 МБ для текстур
```

### Дефрагментация памяти

```cpp
// Запуск дефрагментации памяти
resourceManager.DefragmentMemory();

// Настройка автоматической дефрагментации
resourceManager.SetAutoDefragment(true);
resourceManager.SetDefragmentThreshold(0.3f); // Запуск при 30% фрагментации
```

## Примеры использования

### Загрузка уровня с экраном загрузки

```cpp
// Класс для управления загрузкой уровня
class LevelLoader {
public:
    void LoadLevel(const std::string& levelName) {
        // Показать экран загрузки
        m_LoadingScreen.Show();
        
        // Создание группы загрузки для уровня
        Wudgine::Resources::LoadGroup levelGroup;
        
        // Загрузка манифеста уровня
        auto manifestHandle = m_ResourceManager.LoadJson("levels/" + levelName + "/manifest.json");
        auto manifest = m_ResourceManager.Get<Wudgine::Resources::JsonResource>(manifestHandle);
        
        // Добавление ресурсов из манифеста
        for (const auto& textureInfo : manifest->GetArray("textures")) {
            levelGroup.AddTexture(textureInfo["path"].GetString());
        }
        
        for (const auto& modelInfo : manifest->GetArray("models")) {
            levelGroup.AddModel(modelInfo["path"].GetString());
        }
        
        // Запуск асинхронной загрузки
        m_ResourceManager.LoadGroupAsync(levelGroup, [this, levelName](Wudgine::Resources::LoadGroup& group) {
            // Загрузка завершена, создание уровня
            CreateLevel(levelName);
            
            // Скрыть экран загрузки
            m_LoadingScreen.Hide();
        });
    }
    
    void Update(float deltaTime) {
        // Обновление прогресса загрузки
        if (m_LoadingScreen.IsVisible()) {
            float progress = m_ResourceManager.GetGroupLoadingProgress(m_CurrentLoadGroup);
            m_LoadingScreen.SetProgress(progress);
        }
    }
    
private:
    Wudgine::Resources::ResourceManager& m_ResourceManager;
    Wudgine::UI::LoadingScreen m_LoadingScreen;
    Wudgine::Resources::LoadGroup m_CurrentLoadGroup;
    
    void CreateLevel(const std::string& levelName) {
        // Создание уровня на основе загруженных ресурсов
        // ...
    }
};
```

### Система потоковой загрузки открытого мира

```cpp
// Система управления чанками открытого мира
class OpenWorldChunkManager {
public:
    void Initialize(int worldSize, int chunkSize) {
        m_WorldSize = worldSize;
        m_ChunkSize = chunkSize;
        
        // Вычисление количества чанков
        m_ChunksCount = worldSize / chunkSize;
        
        // Инициализация массива чанков
        m_Chunks.resize(m_ChunksCount * m_ChunksCount);
    }
    
    void Update(const Wudgine::Math::Vector3& playerPosition) {
        // Определение текущего чанка игрока
        int chunkX = static_cast<int>(playerPosition.x) / m_ChunkSize;
        int chunkZ = static_cast<int>(playerPosition.z) / m_ChunkSize;
        
        // Обновление видимости чанков
        for (int z = 0; z < m_ChunksCount; z++) {
            for (int x = 0; x < m_ChunksCount; x++) {
                int distance = std::max(std::abs(x - chunkX), std::abs(z - chunkZ));
                
                Chunk& chunk = GetChunk(x, z);
                
                if (distance <= m_ViewDistance) {
                    // Чанк должен быть загружен
                    if (!chunk.isLoaded) {
                        LoadChunk(x, z);
                    }
                } else {
                    // Чанк должен быть выгружен
                    if (chunk.isLoaded) {
                        UnloadChunk(x, z);
                    }
                }
            }
        }
    }
    
private:
    struct Chunk {
        bool isLoaded = false;
        Wudgine::Resources::LoadGroup resources;
        Wudgine::ECS::Entity chunkEntity;
    };
    
    std::vector<Chunk> m_Chunks;
    int m_WorldSize;
    int m_ChunkSize;
    int m_ChunksCount;
    int m_ViewDistance = 3;
    
    Chunk& GetChunk(int x, int z) {
        return m_Chunks[z * m_ChunksCount + x];
    }
    
    void LoadChunk(int x, int z) {
        Chunk& chunk = GetChunk(x, z);
        
        // Создание группы загрузки для чанка
        Wudgine::Resources::LoadGroup chunkGroup;
        
        // Добавление ресурсов чанка
        std::string chunkPath = "world/chunks/" + std::to_string(x) + "_" + std::to_string(z);
        chunkGroup.AddTexture(chunkPath + "/terrain.png");
        chunkGroup.AddModel(chunkPath + "/terrain.obj");
        
        // Запуск асинхронной загрузки
        m_ResourceManager.LoadGroupAsync(chunkGroup, [this, x, z](Wudgine::Resources::LoadGroup& group) {
            // Создание сущности чанка
            CreateChunkEntity(x, z);
            
            // Отметка чанка как загруженного
            GetChunk(x, z).isLoaded = true;
        });
        
        // Сохранение группы загрузки
        chunk.resources = chunkGroup;
    }
    
    void UnloadChunk(int x, int z) {
        Chunk& chunk = GetChunk(x, z);
        
        // Удаление сущности чанка
        m_World.DestroyEntity(chunk.chunkEntity);
        
        // Выгрузка ресурсов чанка
        m_ResourceManager.UnloadGroup(chunk.resources);
        
        // Отметка чанка как выгруженного
        chunk.isLoaded = false;
    }
    
    void CreateChunkEntity(int x, int z) {
        Chunk& chunk = GetChunk(x, z);
        
        // Создание сущности для чанка
        chunk.chunkEntity = m_World.CreateEntity();
        
        // Добавление компонентов
        auto& transform = m_World.AddComponent<Wudgine::ECS::TransformComponent>(chunk.chunkEntity);
        transform.position = Wudgine::Math::Vector3(x * m_ChunkSize, 0, z * m_ChunkSize);
        
        // Добавление модели
        auto& model = m_World.AddComponent<Wudgine::ECS::ModelComponent>(chunk.chunkEntity);
        std::string modelPath = "world/chunks/" + std::to_string(x) + "_" + std::to_string(z) + "/terrain.obj";
        model.handle = m_ResourceManager.GetHandle(modelPath);
    }
    
    Wudgine::Resources::ResourceManager& m_ResourceManager;
    Wudgine::ECS::World& m_World;
};
```

## Что дальше?

- Изучите [отладку и профилирование](/advanced-topics/debugging-profiling) для анализа производительности системы ресурсов
- Ознакомьтесь с [сетевым взаимодействием](/advanced-topics/networking) для создания многопользовательских игр
- Исследуйте примеры оптимизации ресурсов в [репозитории примеров Wudgine](https://github.com/wudgine/examples)

::alert{type="warning"}
Неэффективное управление ресурсами может привести к утечкам памяти и снижению производительности. Регулярно проводите профилирование и оптимизацию системы ресурсов.
::
