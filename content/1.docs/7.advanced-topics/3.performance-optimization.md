::alert{type="info"}
Оптимизация производительности — ключевой аспект разработки игр, позволяющий создавать плавные и отзывчивые игровые проекты.
::

## Введение в оптимизацию производительности

Оптимизация производительности в Wudgine — это процесс улучшения эффективности вашей игры для достижения стабильной частоты кадров и отзывчивого игрового процесса. В этом разделе мы рассмотрим различные методы и инструменты для выявления и устранения узких мест производительности.

## Профилирование и выявление узких мест

### Встроенные инструменты профилирования

Wudgine предоставляет мощные инструменты профилирования для анализа производительности вашей игры:

```cpp
#include "Wudgine/Core/Profiler.hpp"

void GameLoop() {
    // Начало профилирования секции
    WG_PROFILE_BEGIN("Game Loop");
    
    // Код игрового цикла
    Update();
    Render();
    
    // Завершение профилирования секции
    WG_PROFILE_END();
}

void Update() {
    // Автоматическое профилирование функции
    WG_PROFILE_FUNCTION();
    
    // Код обновления игры
}
```

### Визуализация результатов профилирования

Wudgine включает визуализатор профилирования, который можно вызвать в редакторе:

```cpp
// В коде редакторского инструмента
void RenderProfilerWindow() {
    if (ImGui::Begin("Profiler")) {
        Wudgine::Core::Profiler::RenderImGuiWindow();
    }
    ImGui::End();
}
```

### Анализ производительности CPU

1. **Горячие пути (Hot Paths)** — идентификация функций, занимающих наибольшее время выполнения
2. **Частота вызовов** — анализ функций, вызываемых слишком часто
3. **Время выполнения** — измерение времени выполнения отдельных операций

### Анализ производительности GPU

1. **GPU Profiler** — анализ времени выполнения шейдеров и рендеринга
2. **Счетчики отрисовки** — мониторинг количества вызовов отрисовки и треугольников
3. **Использование памяти GPU** — анализ использования видеопамяти

## Оптимизация рендеринга

### Уровни детализации (LOD)

Система LOD позволяет использовать менее детализированные модели для удаленных объектов:

```cpp
// Компонент LOD
struct LODComponent {
    std::vector<Wudgine::Resources::MeshHandle> meshLevels;
    float[] distanceThresholds;
    
    void UpdateLOD(const Wudgine::Math::Vector3& cameraPosition, 
                   Wudgine::ECS::Entity entity,
                   Wudgine::ECS::Registry& registry) {
        auto& transform = registry.get<TransformComponent>(entity);
        float distance = (transform.position - cameraPosition).Length();
        
        // Выбор подходящего уровня детализации
        int lodLevel = 0;
        for (size_t i = 0; i < distanceThresholds.size(); i++) {
            if (distance > distanceThresholds[i]) {
                lodLevel = i + 1;
            }
        }
        
        // Применение выбранного уровня детализации
        if (lodLevel < meshLevels.size()) {
            auto& renderer = registry.get<MeshRendererComponent>(entity);
            renderer.mesh = meshLevels[lodLevel];
        }
    }
};
```

### Окклюзия и отсечение

Wudgine предоставляет механизмы для отсечения невидимых объектов:

```cpp
// Система отсечения
class CullingSystem : public Wudgine::ECS::System {
public:
    void Update(float deltaTime) override {
        auto& camera = GetWorld()->GetMainCamera();
        auto frustum = camera.GetFrustum();
        
        auto view = GetWorld()->GetRegistry().view<MeshRendererComponent, TransformComponent>();
        view.each([&frustum](auto entity, MeshRendererComponent& renderer, TransformComponent& transform) {
            // Проверка видимости объекта
            Wudgine::Math::BoundingBox worldBounds = transform.TransformBoundingBox(renderer.mesh->GetBoundingBox());
            renderer.visible = frustum.Intersects(worldBounds);
        });
    }
};
```

### Батчинг и инстансинг

Объединение одинаковых объектов для уменьшения количества вызовов отрисовки:

```cpp
// Система батчинга
class BatchingSystem : public Wudgine::ECS::System {
public:
    void Initialize() override {
        // Инициализация системы батчинга
    }
    
    void Update(float deltaTime) override {
        // Группировка объектов по материалам и мешам
        std::unordered_map<MaterialMeshPair, std::vector<Wudgine::Math::Matrix4x4>> instanceGroups;
        
        auto view = GetWorld()->GetRegistry().view<MeshRendererComponent, TransformComponent>();
        view.each([&instanceGroups](auto entity, MeshRendererComponent& renderer, TransformComponent& transform) {
            if (renderer.visible) {
                MaterialMeshPair key{renderer.material, renderer.mesh};
                instanceGroups[key].push_back(transform.GetWorldMatrix());
            }
        });
        
        // Отрисовка сгруппированных объектов
        for (const auto& [key, matrices] : instanceGroups) {
            Wudgine::Rendering::RenderInstanced(key.mesh, key.material, matrices);
        }
    }
};
```

### Оптимизация шейдеров

Советы по оптимизации шейдеров:

1. **Минимизация текстурных выборок** — объединение текстур в атласы
2. **Упрощение вычислений** — использование предварительных вычислений и LUT
3. **Условные операторы** — минимизация ветвлений в шейдерах

Пример оптимизированного шейдера:

```glsl
// Фрагментный шейдер с оптимизацией
#version 330 core

in vec2 TexCoord;
in vec3 Normal;
in vec3 FragPos;

uniform sampler2D albedoMap;
uniform sampler2D normalMap;
uniform sampler2D roughnessMetallicMap; // Объединенная текстура для roughness и metallic

out vec4 FragColor;

void main() {
    // Одна выборка вместо двух отдельных
    vec4 roughnessMetallic = texture(roughnessMetallicMap, TexCoord);
    float roughness = roughnessMetallic.r;
    float metallic = roughnessMetallic.g;
    
    // Остальной код шейдера
    // ...
}
```

## Управление памятью

### Пулы объектов

Использование пулов объектов для уменьшения фрагментации памяти и накладных расходов на выделение/освобождение:

```cpp
#include "Wudgine/Core/ObjectPool.hpp"

// Создание пула для частиц
Wudgine::Core::ObjectPool<ParticleData, 1000> particlePool;

// Получение объекта из пула
ParticleData* particle = particlePool.Allocate();

// Настройка частицы
particle->position = position;
particle->velocity = velocity;
particle->lifetime = 2.0f;

// Возврат объекта в пул после использования
particlePool.Free(particle);
```

### Кэширование и повторное использование

Стратегии кэширования для улучшения производительности:

```cpp
class ResourceCache {
public:
    // Получение ресурса из кэша или загрузка, если его нет
    template<typename T>
    std::shared_ptr<T> GetResource(const std::string& key) {
        auto it = m_Cache.find(key);
        if (it != m_Cache.end()) {
            // Ресурс найден в кэше
            return std::static_pointer_cast<T>(it->second);
        }
        
        // Загрузка ресурса
        std::shared_ptr<T> resource = LoadResource<T>(key);
        m_Cache[key] = resource;
        return resource;
    }
    
    // Очистка неиспользуемых ресурсов
    void CleanupUnused() {
        for (auto it = m_Cache.begin(); it != m_Cache.end();) {
            if (it->second.use_count() == 1) {
                // Только кэш владеет ресурсом, можно удалить
                it = m_Cache.erase(it);
            } else {
                ++it;
            }
        }
    }
    
private:
    std::unordered_map<std::string, std::shared_ptr<void>> m_Cache;
    
    template<typename T>
    std::shared_ptr<T> LoadResource(const std::string& key);
};
```

### Оптимизация структур данных

Выбор подходящих структур данных для конкретных задач:

```cpp
// Пример оптимизированной структуры данных для пространственного поиска
class SpatialHashGrid {
public:
    SpatialHashGrid(float cellSize, int maxEntities)
        : m_CellSize(cellSize), m_InvCellSize(1.0f / cellSize) {
        // Предварительное выделение памяти для уменьшения фрагментации
        m_Grid.reserve(1000);
        m_EntityCells.resize(maxEntities);
    }
    
    void InsertEntity(int entityId, const Wudgine::Math::BoundingBox& bounds) {
        // Вычисление ячеек, которые занимает сущность
        std::vector<GridCell> cells = GetCellsForBounds(bounds);
        
        // Сохранение информации о ячейках для быстрого удаления
        m_EntityCells[entityId] = cells;
        
        // Добавление сущности в ячейки
        for (const auto& cell : cells) {
            m_Grid[cell].push_back(entityId);
        }
    }
    
    void RemoveEntity(int entityId) {
        // Быстрое удаление из всех ячеек
        for (const auto& cell : m_EntityCells[entityId]) {
            auto& entities = m_Grid[cell];
            entities.erase(std::remove(entities.begin(), entities.end(), entityId), entities.end());
        }
        
        m_EntityCells[entityId].clear();
    }
    
    std::vector<int> GetNearbyEntities(const Wudgine::Math::Vector3& position, float radius) {
        std::vector<int> result;
        std::unordered_set<int> uniqueEntities;
        
        // Получение ячеек в радиусе
        std::vector<GridCell> cells = GetCellsForSphere(position, radius);
        
        // Сбор сущностей из ячеек
        for (const auto& cell : cells) {
            auto it = m_Grid.find(cell);
            if (it != m_Grid.end()) {
                for (int entityId : it->second) {
                    uniqueEntities.insert(entityId);
                }
            }
        }
        
        result.assign(uniqueEntities.begin(), uniqueEntities.end());
        return result;
    }
    
private:
    using GridCell = std::tuple<int, int, int>;
    
    float m_CellSize;
    float m_InvCellSize;
    std::unordered_map<GridCell, std::vector<int>, GridCellHash> m_Grid;
    std::vector<std::vector<GridCell>> m_EntityCells;
    
    // Вспомогательные методы
    std::vector<GridCell> GetCellsForBounds(const Wudgine::Math::BoundingBox& bounds);
    std::vector<GridCell> GetCellsForSphere(const Wudgine::Math::Vector3& position, float radius);
};
```

## Оптимизация физики и коллизий

### Пространственное разделение

Использование пространственных структур данных для ускорения поиска коллизий:

```cpp
// Система физики с пространственным разделением
class OptimizedPhysicsSystem : public Wudgine::ECS::System {
public:
    void Initialize() override {
        m_SpatialGrid = std::make_unique<SpatialHashGrid>(10.0f, 10000);
    }
    
    void Update(float deltaTime) override {
        // Обновление пространственной сетки
        UpdateSpatialGrid();
        
        // Обработка коллизий только между потенциально пересекающимися объектами
        auto view = GetWorld()->GetRegistry().view<ColliderComponent, TransformComponent>();
        view.each([this, deltaTime](auto entity, ColliderComponent& collider, TransformComponent& transform) {
            // Получение ближайших объектов
            auto nearbyEntities = m_SpatialGrid->GetNearbyEntities(transform.position, collider.boundingSphere.radius);
            
            // Проверка коллизий только с ближайшими объектами
            for (int otherEntity : nearbyEntities) {
                if (otherEntity != entity) {
                    CheckCollision(entity, otherEntity);
                }
            }
        });
    }
    
private:
    std::unique_ptr<SpatialHashGrid> m_SpatialGrid;
    
    void UpdateSpatialGrid() {
        // Обновление положения всех объектов в сетке
        auto view = GetWorld()->GetRegistry().view<ColliderComponent, TransformComponent>();
        view.each([this](auto entity, ColliderComponent& collider, TransformComponent& transform) {
            // Обновление положения в сетке
            m_SpatialGrid->RemoveEntity(entity);
            
            // Вычисление мирового ограничивающего объема
            Wudgine::Math::BoundingBox worldBounds = transform.TransformBoundingBox(collider.boundingBox);
            
            m_SpatialGrid->InsertEntity(entity, worldBounds);
        });
    }
    
    void CheckCollision(int entityA, int entityB) {
        // Детальная проверка коллизии между двумя сущностями
    }
};
```

### Упрощенные коллайдеры

Использование упрощенных коллайдеров для быстрых проверок:

```cpp
// Компонент с упрощенными коллайдерами
struct OptimizedColliderComponent {
    // Точный коллайдер для финальной проверки
    Wudgine::Physics::Collider preciseCollider;
    
    // Упрощенный коллайдер для быстрой проверки
    Wudgine::Math::BoundingSphere boundingSphere;
    Wudgine::Math::BoundingBox boundingBox;
    
    // Двухэтапная проверка коллизии
    bool CheckCollision(const OptimizedColliderComponent& other, 
                        const Wudgine::Math::Matrix4x4& thisTransform,
                        const Wudgine::Math::Matrix4x4& otherTransform) {
        // Быстрая проверка с использованием ограничивающих объемов
        if (!boundingSphere.Intersects(other.boundingSphere, thisTransform, otherTransform)) {
            return false; // Быстрый отказ
        }
        
        if (!boundingBox.Intersects(other.boundingBox, thisTransform, otherTransform)) {
            return false; // Второй уровень быстрого отказа
        }
        
        // Точная проверка коллизии
        return preciseCollider.CheckCollision(other.preciseCollider, thisTransform, otherTransform);
    }
};
```

## Оптимизация для различных платформ

### Мобильные устройства

Специфические оптимизации для мобильных платформ:

1. **Уменьшение количества вызовов отрисовки** — агрессивный батчинг
2. **Оптимизация шейдеров** — упрощение вычислений, меньше текстурных выборок
3. **Управление энергопотреблением** — адаптивное качество графики

```cpp
// Система адаптивного качества для мобильных устройств
class AdaptiveQualitySystem : public Wudgine::ECS::System {
public:
    void Update(float deltaTime) override {
        // Измерение FPS
        m_FrameTimeAccumulator += deltaTime;
        m_FrameCount++;
        
        if (m_FrameTimeAccumulator >= 1.0f) {
            float averageFPS = m_FrameCount / m_FrameTimeAccumulator;
            m_FrameTimeAccumulator = 0.0f;
            m_FrameCount = 0;
            
            // Адаптация качества в зависимости от FPS
            if (averageFPS < 30.0f) {
                DecreaseQuality();
            } else if (averageFPS > 55.0f && m_QualityLevel < m_MaxQualityLevel) {
                IncreaseQuality();
            }
        }
    }
    
private:
    float m_FrameTimeAccumulator = 0.0f;
    int m_FrameCount = 0;
    int m_QualityLevel = 2;
    int m_MaxQualityLevel = 4;
    
    void DecreaseQuality() {
        if (m_QualityLevel > 0) {
            m_QualityLevel--;
            ApplyQualitySettings();
        }
    }
    
    void IncreaseQuality() {
        if (m_QualityLevel < m_MaxQualityLevel) {
            m_QualityLevel++;
            ApplyQualitySettings();
        }
    }
    
    void ApplyQualitySettings() {
        // Применение настроек качества
        auto& renderer = GetWorld()->GetSystem<RenderSystem>();
        
        switch (m_QualityLevel) {
            case 0: // Очень низкое
                renderer.SetShadowQuality(0);
                renderer.SetTextureQuality(0.25f);
                renderer.SetMaxLights(4);
                renderer.SetPostProcessingEnabled(false);
                break;
            case 1: // Низкое
                renderer.SetShadowQuality(1);
                renderer.SetTextureQuality(0.5f);
                renderer.SetMaxLights(8);
                renderer.SetPostProcessingEnabled(false);
                break;
            // И так далее для других уровней качества
        }
    }
};
```

### Консоли

Оптимизации для игровых консолей:

1. **Использование специфичных API** — оптимизация под конкретное железо
2. **Асинхронные вычисления** — использование асинхронных вычислений GPU
3. **Оптимизация памяти** — учет особенностей памяти консолей

### ПК

Оптимизации для ПК:

1. **Масштабируемость** — настройки для различных конфигураций
2. **Многопоточность** — эффективное использование многоядерных процессоров
3. **Поддержка различных API** — DirectX, Vulkan, OpenGL

## Лучшие практики оптимизации

### Измеряйте перед оптимизацией

Всегда профилируйте код перед оптимизацией, чтобы выявить реальные узкие места:

```cpp
void OptimizeGame() {
    // Профилирование перед оптимизацией
    Wudgine::Core::Profiler::BeginSession("Before Optimization");
    RunBenchmark();
    Wudgine::Core::Profiler::EndSession();
    
    // Анализ результатов и выявление узких мест
    auto hotspots = Wudgine::Core::Profiler::GetHotspots();
    
    // Оптимизация выявленных узких мест
    // ...
    
    // Профилирование после оптимизации для проверки результатов
    Wudgine::Core::Profiler::BeginSession("After Optimization");
    RunBenchmark();
    Wudgine::Core::Profiler::EndSession();
    
    // Сравнение результатов
    CompareProfilingResults("Before Optimization", "After Optimization");
}
```

### Оптимизируйте данные, а не код

Часто оптимизация структур данных и их размещения в памяти дает больший эффект, чем оптимизация алгоритмов:

```cpp
// Оптимизация структуры данных для лучшей локальности кэша
struct OptimizedEntityData {
    // Группировка часто используемых вместе данных
    struct TransformData {
        Wudgine::Math::Vector3 position;
        Wudgine::Math::Quaternion rotation;
        Wudgine::Math::Vector3 scale;
    };
    
    struct RenderData {
        Wudgine::Resources::MeshHandle mesh;
        Wudgine::Resources::MaterialHandle material;
        bool visible;
    };
    
    // Массивы структур вместо структур массивов для лучшей локальности кэша
    std::vector<TransformData> transforms;
    std::vector<RenderData> renderData;
    
    // Методы для работы с данными
};
```

### Используйте инкрементальные оптимизации

Оптимизируйте постепенно, измеряя результаты каждого изменения:

```cpp
void IncrementalOptimization() {
    // Исходное профилирование
    float baselinePerformance = MeasurePerformance();
    
    // Первая оптимизация
    OptimizeRenderingPipeline();
    float performance1 = MeasurePerformance();
    LogPerformanceImprovement("Rendering Pipeline", baselinePerformance, performance1);
    
    // Вторая оптимизация
    OptimizePhysics();
    float performance2 = MeasurePerformance();
    LogPerformanceImprovement("Physics", performance1, performance2);
    
    // Третья оптимизация
    OptimizeMemoryUsage();
    float performance3 = MeasurePerformance();
    LogPerformanceImprovement("Memory Usage", performance2, performance3);
    
    // Общее улучшение
    LogPerformanceImprovement("Total", baselinePerformance, performance3);
}
```

## Что дальше?

- Изучите [сетевое взаимодействие](/advanced-topics/networking) для создания многопользовательских игр
- Ознакомьтесь с [расширенной работой с ресурсами](/advanced-topics/advanced-resources) для оптимизации загрузки и управления игровыми ресурсами
- Исследуйте [отладку и профилирование](/advanced-topics/debugging-profiling) для более глубокого анализа производительности

::alert{type="success"}
Оптимизация — это итеративный процесс. Регулярно профилируйте вашу игру на различных устройствах и постоянно ищите возможности для улучшения производительности.
::
