::alert{type="info"}
Эффективная отладка и профилирование — ключевые навыки для оптимизации производительности игр на Wudgine. В этом разделе рассматриваются инструменты и методики для выявления и устранения проблем.
::

## Введение

Отладка и профилирование являются неотъемлемой частью разработки игр. Wudgine предоставляет набор инструментов, которые помогают выявлять и устранять проблемы производительности, утечки памяти и другие ошибки.

## Встроенные инструменты отладки

### Консоль отладки

Wudgine включает встроенную консоль отладки, которая позволяет просматривать логи и выполнять команды во время работы игры.

```cpp
// Включение консоли отладки
Wudgine::Debug::Console::Initialize();

// Регистрация пользовательской команды
Wudgine::Debug::Console::RegisterCommand("spawn_enemy", [](const std::vector<std::string>& args) {
    if (args.size() < 2) {
        return "Использование: spawn_enemy <тип> <количество>";
    }
    
    std::string enemyType = args[0];
    int count = std::stoi(args[1]);
    
    for (int i = 0; i < count; i++) {
        // Создание врага указанного типа
        SpawnEnemy(enemyType);
    }
    
    return "Создано " + std::to_string(count) + " врагов типа " + enemyType;
});

// Вывод сообщения в консоль
Wudgine::Debug::Console::Log("Инициализация игры завершена");
Wudgine::Debug::Console::LogWarning("Ресурс не найден: textures/missing.png");
Wudgine::Debug::Console::LogError("Критическая ошибка при загрузке уровня");
```

### Визуализация отладочной информации

```cpp
// Создание отладочного рендерера
Wudgine::Debug::DebugRenderer debugRenderer;

// Отрисовка отладочных примитивов
void Update(float deltaTime) {
    // Отрисовка коллайдеров
    for (auto entity : physicsSystem.GetEntities()) {
        auto& collider = world.GetComponent<Wudgine::Physics::ColliderComponent>(entity);
        auto& transform = world.GetComponent<Wudgine::ECS::TransformComponent>(entity);
        
        // Отрисовка коллайдера в зависимости от его типа
        switch (collider.type) {
            case Wudgine::Physics::ColliderType::Box:
                debugRenderer.DrawBox(transform.position, collider.size, transform.rotation, 
                                     Wudgine::Math::Color(0, 1, 0, 0.5f));
                break;
            case Wudgine::Physics::ColliderType::Sphere:
                debugRenderer.DrawSphere(transform.position, collider.radius, 
                                        Wudgine::Math::Color(0, 1, 0, 0.5f));
                break;
        }
    }
    
    // Отрисовка путей навигации
    for (auto& path : navigationSystem.GetActivePaths()) {
        debugRenderer.DrawPath(path.points, Wudgine::Math::Color(0, 0, 1, 1.0f));
    }
    
    // Отрисовка направлений и векторов
    debugRenderer.DrawArrow(player.position, player.position + player.velocity * 2.0f, 
                           Wudgine::Math::Color(1, 0, 0, 1.0f));
}
```

## Профилирование производительности

### Встроенный профилировщик

Wudgine включает встроенный профилировщик для измерения производительности различных частей игры.

```cpp
// Инициализация профилировщика
Wudgine::Profiling::Profiler::Initialize();

// Профилирование функции или блока кода
void Update(float deltaTime) {
    WUDGINE_PROFILE_FUNCTION(); // Автоматически профилирует всю функцию
    
    {
        WUDGINE_PROFILE_SCOPE("Physics Update"); // Профилирование конкретного блока кода
        physicsSystem.Update(deltaTime);
    }
    
    {
        WUDGINE_PROFILE_SCOPE("AI Update");
        aiSystem.Update(deltaTime);
    }
    
    {
        WUDGINE_PROFILE_SCOPE("Rendering");
        renderSystem.Render();
    }
}

// Сохранение результатов профилирования
void OnGameExit() {
    Wudgine::Profiling::Profiler::SaveResults("profile_results.json");
}
```

### Интеграция с внешними профилировщиками

```cpp
// Интеграция с Tracy Profiler
#include "TracyWudgine.h"

void GameLoop() {
    while (running) {
        ZoneScoped; // Tracy: профилирование всего кадра
        
        {
            ZoneScopedN("Input Processing"); // Tracy: именованная зона профилирования
            ProcessInput();
        }
        
        {
            ZoneScopedN("Update");
            Update(deltaTime);
        }
        
        {
            ZoneScopedN("Render");
            Render();
        }
        
        FrameMark; // Tracy: отметка конца кадра
    }
}
```

## Отладка памяти

### Отслеживание утечек памяти

```cpp
// Включение отслеживания памяти
Wudgine::Debug::MemoryTracker::Initialize();

// Получение статистики использования памяти
void DisplayMemoryStats() {
    auto stats = Wudgine::Debug::MemoryTracker::GetStats();
    
    std::cout << "Статистика памяти:" << std::endl;
    std::cout << "- Всего выделено: " << stats.totalAllocated / (1024 * 1024) << " МБ" << std::endl;
    std::cout << "- Всего освобождено: " << stats.totalFreed / (1024 * 1024) << " МБ" << std::endl;
    std::cout << "- Текущее использование: " << stats.currentUsage / (1024 * 1024) << " МБ" << std::endl;
    std::cout << "- Пиковое использование: " << stats.peakUsage / (1024 * 1024) << " МБ" << std::endl;
    std::cout << "- Количество активных выделений: " << stats.activeAllocations << std::endl;
}
```

### Создание снимков памяти для сравнения

```cpp
// Создание снимка памяти для сравнения
void CheckForLeaks() {
    // Создание снимка текущего состояния памяти
    auto snapshot1 = Wudgine::Debug::MemoryTracker::CreateSnapshot();
    
    // Выполнение операций, которые могут вызывать утечки
    LoadLevel("test_level");
    UnloadLevel("test_level");
    
    // Создание второго снимка
    auto snapshot2 = Wudgine::Debug::MemoryTracker::CreateSnapshot();
    
    // Сравнение снимков для выявления утечек
    auto diff = Wudgine::Debug::MemoryTracker::CompareSnapshots(snapshot1, snapshot2);
    
    if (diff.newAllocations.empty()) {
        std::cout << "Утечек памяти не обнаружено!" << std::endl;
    } else {
        std::cout << "Обнаружены потенциальные утечки памяти:" << std::endl;
        for (const auto& alloc : diff.newAllocations) {
            std::cout << "- " << alloc.size << " байт в " << alloc.file << ":" << alloc.line << std::endl;
        }
    }
}
```

## Отладка рендеринга

### Визуализация буферов рендеринга

```cpp
// Отображение различных буферов рендеринга
void RenderDebugBuffers() {
    if (Wudgine::Debug::ImGui::Begin("Debug Buffers")) {
        // Получение текстур буферов
        auto colorBuffer = renderer.GetColorBufferTexture();
        auto depthBuffer = renderer.GetDepthBufferTexture();
        auto normalBuffer = renderer.GetGBufferTexture(Wudgine::Rendering::GBufferType::Normal);
        auto velocityBuffer = renderer.GetGBufferTexture(Wudgine::Rendering::GBufferType::Velocity);
        
        // Отображение буферов
        Wudgine::Debug::ImGui::Text("Color Buffer");
        Wudgine::Debug::ImGui::Image(colorBuffer, ImVec2(200, 200));
        
        Wudgine::Debug::ImGui::Text("Depth Buffer");
        Wudgine::Debug::ImGui::Image(depthBuffer, ImVec2(200, 200));
        
        Wudgine::Debug::ImGui::Text("Normal Buffer");
        Wudgine::Debug::ImGui::Image(normalBuffer, ImVec2(200, 200));
        
        Wudgine::Debug::ImGui::Text("Velocity Buffer");
        Wudgine::Debug::ImGui::Image(velocityBuffer, ImVec2(200, 200));
        
        Wudgine::Debug::ImGui::End();
    }
}
```

### Отладка шейдеров

```cpp
// Включение отладки шейдеров
Wudgine::Rendering::ShaderDebugger::Initialize();

// Отладка конкретного шейдера
void DebugShader(const std::string& shaderName) {
    auto debugInfo = Wudgine::Rendering::ShaderDebugger::DebugShader(shaderName);
    
    std::cout << "Отладка шейдера: " << shaderName << std::endl;
    std::cout << "- Время компиляции: " << debugInfo.compilationTimeMs << " мс" << std::endl;
    std::cout << "- Использование регистров: " << debugInfo.registerUsage << "%" << std::endl;
    
    if (!debugInfo.warnings.empty()) {
        std::cout << "Предупреждения:" << std::endl;
        for (const auto& warning : debugInfo.warnings) {
            std::cout << "- " << warning << std::endl;
        }
    }
}
```

## Отладка физики

### Визуализация физических объектов

```cpp
// Включение визуализации физики
Wudgine::Physics::Debug::EnableVisualization();

// Настройка параметров визуализации
Wudgine::Physics::Debug::SetVisualizationOptions({
    .showColliders = true,
    .showContacts = true,
    .showJoints = true,
    .showAABBs = false,
    .showVelocities = true,
    .colliderColor = Wudgine::Math::Color(0, 1, 0, 0.5f),
    .contactColor = Wudgine::Math::Color(1, 0, 0, 1.0f),
    .jointColor = Wudgine::Math::Color(0, 0, 1, 1.0f),
    .velocityColor = Wudgine::Math::Color(1, 1, 0, 1.0f)
});
```

### Отладка столкновений

```cpp
// Регистрация обратного вызова для отладки столкновений
Wudgine::Physics::Debug::RegisterCollisionCallback([](const Wudgine::Physics::CollisionInfo& info) {
    std::cout << "Столкновение между объектами " << info.entityA << " и " << info.entityB << std::endl;
    std::cout << "- Точка контакта: " << info.contactPoint.x << ", " 
              << info.contactPoint.y << ", " << info.contactPoint.z << std::endl;
    std::cout << "- Нормаль: " << info.normal.x << ", " 
              << info.normal.y << ", " << info.normal.z << std::endl;
    std::cout << "- Глубина проникновения: " << info.penetrationDepth << std::endl;
    
    // Можно также визуализировать точку контакта
    Wudgine::Debug::DebugRenderer::DrawSphere(info.contactPoint, 0.1f, 
                                             Wudgine::Math::Color(1, 0, 0, 1.0f), 2.0f);
});
```

## Отладка искусственного интеллекта

### Визуализация поведения ИИ

```cpp
// Визуализация зон восприятия ИИ
void DebugAIPerception() {
    for (auto entity : aiSystem.GetEntities()) {
        auto& perception = world.GetComponent<Wudgine::AI::PerceptionComponent>(entity);
        auto& transform = world.GetComponent<Wudgine::ECS::TransformComponent>(entity);
        
        // Визуализация зоны видимости
        if (perception.hasVision) {
            debugRenderer.DrawCone(transform.position, transform.forward, 
                                  perception.visionRange, perception.visionAngle,
                                  Wudgine::Math::Color(1, 1, 0, 0.3f));
        }
        
        // Визуализация зоны слышимости
        if (perception.hasHearing) {
            debugRenderer.DrawSphere(transform.position, perception.hearingRange,
                                    Wudgine::Math::Color(0, 1, 1, 0.3f));
        }
        
        // Визуализация обнаруженных целей
        for (const auto& target : perception.detectedTargets) {
            debugRenderer.DrawLine(transform.position, target.position,
                                  Wudgine::Math::Color(1, 0, 0, 1.0f));
        }
    }
}
```

### Отладка деревьев поведения

```cpp
// Включение отладки деревьев поведения
Wudgine::AI::BehaviorTreeDebugger::Initialize();

// Регистрация дерева поведения для отладки
void RegisterBehaviorTreeForDebugging(Wudgine::AI::BehaviorTree* tree, const std::string& name) {
    Wudgine::AI::BehaviorTreeDebugger::RegisterTree(tree, name);
}

// Отображение состояния дерева поведения
void RenderBehaviorTreeDebugger() {
    if (Wudgine::Debug::ImGui::Begin("Behavior Tree Debugger")) {
        // Выбор дерева поведения для отображения
        static int selectedTree = 0;
        auto treeNames = Wudgine::AI::BehaviorTreeDebugger::GetRegisteredTreeNames();
        
        if (Wudgine::Debug::ImGui::Combo("Tree", &selectedTree, treeNames)) {
            Wudgine::AI::BehaviorTreeDebugger::SetActiveTree(treeNames[selectedTree]);
        }
        
        // Отображение структуры дерева
        Wudgine::AI::BehaviorTreeDebugger::RenderActiveTree();
        
        Wudgine::Debug::ImGui::End();
    }
}
```

## Отладка сети

### Мониторинг сетевого трафика

```cpp
// Включение мониторинга сетевого трафика
Wudgine::Networking::Debug::EnableTrafficMonitoring();

// Отображение статистики сетевого трафика
void DisplayNetworkStats() {
    auto stats = Wudgine::Networking::Debug::GetTrafficStats();
    
    std::cout << "Статистика сети:" << std::endl;
    std::cout << "- Отправлено пакетов: " << stats.packetsSent << std::endl;
    std::cout << "- Получено пакетов: " << stats.packetsReceived << std::endl;
    std::cout << "- Отправлено байт: " << stats.bytesSent / 1024.0f << " КБ" << std::endl;
    std::cout << "- Получено байт: " << stats.bytesReceived / 1024.0f << " КБ" << std::endl;
    std::cout << "- Средняя задержка: " << stats.averagePing << " мс" << std::endl;
    std::cout << "- Потеряно пакетов: " << stats.packetsLost << " (" 
              << (stats.packetsSent > 0 ? (stats.packetsLost * 100.0f / stats.packetsSent) : 0.0f) 
              << "%)" << std::endl;
}

// Логирование сетевых сообщений
Wudgine::Networking::Debug::SetMessageLoggingLevel(Wudgine::Networking::Debug::LogLevel::Verbose);
```

### Симуляция сетевых условий

```cpp
// Настройка симуляции сетевых условий
void SimulateNetworkConditions() {
    Wudgine::Networking::Debug::NetworkConditions conditions;
    
    // Симуляция плохого соединения
    conditions.packetLossPercentage = 5.0f;  // 5% потери пакетов
    conditions.minimumLatencyMs = 50;        // Минимальная задержка 50 мс
    conditions.additionalRandomLatencyMs = 100; // Случайная дополнительная задержка до 100 мс
    conditions.jitterMs = 20;                // Джиттер 20 мс
    
    Wudgine::Networking::Debug::SetNetworkConditions(conditions);
    
    // Запуск симуляции на 60 секунд
    Wudgine::Networking::Debug::EnableNetworkSimulation(true, 60.0f);
}
```

## Автоматизированное тестирование

### Модульное тестирование

```cpp
// Пример модульного теста с использованием встроенного фреймворка тестирования
WUDGINE_TEST_CASE("Physics - Collision Detection") {
    // Настройка тестового окружения
    Wudgine::Physics::World physicsWorld;
    
    // Создание тестовых объектов
    auto boxA = physicsWorld.CreateBox({0, 0, 0}, {1, 1, 1}, 1.0f);
    auto boxB = physicsWorld.CreateBox({0.5f, 0, 0}, {1, 1, 1}, 1.0f);
    
    // Выполнение теста
    physicsWorld.Step(1.0f / 60.0f);
    
    // Проверка результатов
    auto contacts = physicsWorld.GetContacts();
    WUDGINE_CHECK(!contacts.empty());
    WUDGINE_CHECK(contacts[0].entityA == boxA || contacts[0].entityA == boxB);
    WUDGINE_CHECK(contacts[0].entityB == boxA || contacts[0].entityB == boxB);
    WUDGINE_CHECK(contacts[0].entityA != contacts[0].entityB);
}
```

### Интеграционное тестирование

```cpp
// Пример интеграционного теста
WUDGINE_TEST_CASE("Game Systems Integration") {
    // Инициализация игровых систем
    Wudgine::ECS::World world;
    Wudgine::Physics::PhysicsSystem physicsSystem(&world);
    Wudgine::AI::AISystem aiSystem(&world);
    
    // Настройка тестового сценария
    auto player = world.CreateEntity();
    world.AddComponent<Wudgine::ECS::TransformComponent>(player, {{0, 0, 0}, {0, 0, 0, 1}, {1, 1, 1}});
    world.AddComponent<Wudgine::Physics::RigidbodyComponent>(player, {1.0f, false});
    
    auto enemy = world.CreateEntity();
    world.AddComponent<Wudgine::ECS::TransformComponent>(enemy, {{5, 0, 0}, {0, 0, 0, 1}, {1, 1, 1}});
    world.AddComponent<Wudgine::AI::BehaviorComponent>(enemy, {"chase_player"});
    
    // Выполнение тестового сценария
    for (int i = 0; i < 60; i++) {
        physicsSystem.Update(1.0f / 60.0f);
        aiSystem.Update(1.0f / 60.0f);
    }
    
    // Проверка результатов
    auto& enemyTransform = world.GetComponent<Wudgine::ECS::TransformComponent>(enemy);
    auto& playerTransform = world.GetComponent<Wudgine::ECS::TransformComponent>(player);
    
    // Проверяем, что враг приблизился к игроку
    float distance = Wudgine::Math::Vector3::Distance(enemyTransform.position, playerTransform.position);
    WUDGINE_CHECK(distance < 5.0f);
}
```

### Стресс-тестирование

```cpp
// Пример стресс-теста
WUDGINE_TEST_CASE("Rendering System Stress Test") {
    // Инициализация системы рендеринга
    Wudgine::Rendering::Renderer renderer;
    
    // Создание большого количества объектов для рендеринга
    const int objectCount = 10000;
    std::vector<Wudgine::Rendering::MeshInstance> instances;
    
    auto mesh = Wudgine::Resources::ResourceManager::LoadMesh("models/cube.obj");
    auto material = Wudgine::Resources::ResourceManager::LoadMaterial("materials/standard.mat");
    
    for (int i = 0; i < objectCount; i++) {
        Wudgine::Rendering::MeshInstance instance;
        instance.mesh = mesh;
        instance.material = material;
        instance.transform = Wudgine::Math::Matrix4x4::Translation(
            Wudgine::Math::Vector3(
                Wudgine::Math::Random::Range(-100.0f, 100.0f),
                Wudgine::Math::Random::Range(-100.0f, 100.0f),
                Wudgine::Math::Random::Range(-100.0f, 100.0f)
            )
        );
        instances.push_back(instance);
    }
    
    // Измерение производительности рендеринга
    Wudgine::Profiling::ScopedTimer timer("Rendering Stress Test");
    
    for (int frame = 0; frame < 100; frame++) {
        renderer.BeginFrame();
        renderer.RenderInstances(instances);
        renderer.EndFrame();
    }
    
    auto elapsedTime = timer.GetElapsedMilliseconds();
    auto averageFrameTime = elapsedTime / 100.0f;
    
    std::cout << "Стресс-тест рендеринга:" << std::endl;
    std::cout << "- Количество объектов: " << objectCount << std::endl;
    std::cout << "- Общее время: " << elapsedTime << " мс" << std::endl;
    std::cout << "- Среднее время кадра: " << averageFrameTime << " мс" << std::endl;
    std::cout << "- Средний FPS: " << 1000.0f / averageFrameTime << std::endl;
    
    // Проверка результатов
    WUDGINE_CHECK(averageFrameTime < 33.3f); // Минимум 30 FPS
}
```

## Анализ производительности CPU и GPU

### Анализ производительности CPU

```cpp
// Включение анализа производительности CPU
Wudgine::Profiling::CPUProfiler::Initialize();

// Запуск анализа
void AnalyzeCPUPerformance() {
    Wudgine::Profiling::CPUProfiler::BeginSession("GameLoop");
    
    // Выполнение игрового цикла
    for (int i = 0; i < 1000; i++) {
        {
            WUDGINE_CPU_PROFILE_SCOPE("Input");
            ProcessInput();
        }
        
        {
            WUDGINE_CPU_PROFILE_SCOPE("Update");
            Update(1.0f / 60.0f);
        }
        
        {
            WUDGINE_CPU_PROFILE_SCOPE("Render");
            Render();
        }
    }
    
    // Завершение анализа и сохранение результатов
    Wudgine::Profiling::CPUProfiler::EndSession();
    Wudgine::Profiling::CPUProfiler::SaveResults("cpu_profile.json");
}
```

### Анализ производительности GPU

```cpp
// Включение анализа производительности GPU
Wudgine::Profiling::GPUProfiler::Initialize();

// Запуск анализа
void AnalyzeGPUPerformance() {
    Wudgine::Profiling::GPUProfiler::BeginSession("RenderingPipeline");
    
    // Выполнение рендеринга
    for (int i = 0; i < 100; i++) {
        renderer.BeginFrame();
        
        {
            WUDGINE_GPU_PROFILE_SCOPE("Shadow Maps");
            renderer.RenderShadowMaps();
        }
        
        {
            WUDGINE_GPU_PROFILE_SCOPE("GBuffer");
            renderer.RenderGBuffer();
        }
        
        {
            WUDGINE_GPU_PROFILE_SCOPE("Lighting");
            renderer.RenderLighting();
        }
        
        {
            WUDGINE_GPU_PROFILE_SCOPE("Post-Processing");
            renderer.RenderPostProcessing();
        }
        
        renderer.EndFrame();
    }
    
    // Завершение анализа и сохранение результатов
    Wudgine::Profiling::GPUProfiler::EndSession();
    Wudgine::Profiling::GPUProfiler::SaveResults("gpu_profile.json");
}
```

## Примеры использования

### Отладка утечек памяти

```cpp
// Пример отладки утечек памяти
void DebugMemoryLeaks() {
    // Включение отслеживания памяти
    Wudgine::Debug::MemoryTracker::Initialize();
    
    // Создание снимка памяти перед выполнением операций
    auto beforeSnapshot = Wudgine::Debug::MemoryTracker::CreateSnapshot();
    
    // Выполнение операций, которые могут вызывать утечки
    {
        // Намеренная утечка памяти для демонстрации
        auto* leakedData = new char[1024 * 1024]; // 1 МБ
        std::cout << "Выделено " << leakedData << std::endl;
        // Отсутствует delete[]
    }
    
    // Принудительный сбор мусора (если применимо)
    Wudgine::Memory::GarbageCollector::Collect();
    
    // Создание снимка памяти после выполнения операций
    auto afterSnapshot = Wudgine::Debug::MemoryTracker::CreateSnapshot();
    
    // Сравнение снимков для выявления утечек
    auto diff = Wudgine::Debug::MemoryTracker::CompareSnapshots(beforeSnapshot, afterSnapshot);
    
    // Вывод результатов
    if (diff.newAllocations.empty()) {
        std::cout << "Утечек памяти не обнаружено!" << std::endl;
    } else {
        std::cout << "Обнаружены потенциальные утечки памяти:" << std::endl;
        for (const auto& alloc : diff.newAllocations) {
            std::cout << "- " << alloc.size << " байт в " << alloc.file << ":" << alloc.line << std::endl;
        }
    }
}
```

### Профилирование производительности игры

```cpp
// Пример профилирования производительности игры
void ProfileGamePerformance() {
    // Инициализация профилировщика
    Wudgine::Profiling::Profiler::Initialize();
    
    // Настройка параметров профилирования
    Wudgine::Profiling::ProfilerSettings settings;
    settings.captureFrameCount = 100;     // Количество кадров для профилирования
    settings.samplingFrequency = 1000;    // Частота сэмплирования (Гц)
    settings.outputFile = "game_profile.json";
    
    Wudgine::Profiling::Profiler::Configure(settings);
    
    // Запуск профилирования
    Wudgine::Profiling::Profiler::StartCapture();
    
    // Выполнение игрового цикла
    for (int i = 0; i < settings.captureFrameCount; i++) {
        WUDGINE_PROFILE_FRAME("Frame " + std::to_string(i));
        
        {
            WUDGINE_PROFILE_SCOPE("Input");
            ProcessInput();
        }
        
        {
            WUDGINE_PROFILE_SCOPE("Physics");
            physicsSystem.Update(1.0f / 60.0f);
        }
        
        {
            WUDGINE_PROFILE_SCOPE("AI");
            aiSystem.Update(1.0f / 60.0f);
        }
        
        {
            WUDGINE_PROFILE_SCOPE("Game Logic");
            gameLogicSystem.Update(1.0f / 60.0f);
        }
        
        {
            WUDGINE_PROFILE_SCOPE("Rendering");
            renderSystem.Render();
        }
    }
    
    // Остановка профилирования и сохранение результатов
    Wudgine::Profiling::Profiler::StopCapture();
    
    // Анализ результатов
    auto results = Wudgine::Profiling::Profiler::GetResults();
    
    std::cout << "Результаты профилирования:" << std::endl;
    std::cout << "- Среднее время кадра: " << results.averageFrameTime << " мс" << std::endl;
    std::cout << "- Минимальное время кадра: " << results.minFrameTime << " мс" << std::endl;
    std::cout << "- Максимальное время кадра: " << results.maxFrameTime << " мс" << std::endl;
    std::cout << "- 99-й процентиль: " << results.percentile99 << " мс" << std::endl;
    
    // Вывод времени выполнения по категориям
    for (const auto& category : results.categories) {
        std::cout << "- " << category.name << ": " 
                  << category.averageTime << " мс (" 
                  << (category.averageTime / results.averageFrameTime * 100.0f) << "%)" << std::endl;
    }
}
```

## Связанные разделы

- [Многопоточность](/advanced-topics/multithreading) - Узнайте, как использовать многопоточность для повышения производительности.
- [Оптимизация производительности](/advanced-topics/performance-optimization) - Изучите методы оптимизации производительности игры.
- [Продвинутое управление ресурсами](/advanced-topics/advanced-resources) - Узнайте о продвинутых методах управления ресурсами.
