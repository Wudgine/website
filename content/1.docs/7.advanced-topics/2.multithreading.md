::alert{type="info"}
Многопоточность позволяет максимально использовать возможности современных многоядерных процессоров, значительно повышая производительность игр.
::

## Введение в многопоточность

Современные игры требуют эффективного использования всех доступных ресурсов процессора. Wudgine предоставляет мощную систему многопоточности, которая позволяет распараллеливать вычисления и оптимизировать производительность игры.

## Система заданий (Job System)

Система заданий Wudgine — это высокоуровневый интерфейс для работы с потоками, который позволяет легко распараллеливать вычисления.

### Основные концепции

- **Задание (Job)** — атомарная единица работы, которая может быть выполнена параллельно
- **Пул потоков (Thread Pool)** — набор рабочих потоков для выполнения заданий
- **Планировщик (Scheduler)** — компонент, распределяющий задания между потоками
- **Зависимости (Dependencies)** — механизм синхронизации между заданиями

### Создание и выполнение заданий

```cpp
#include "Wudgine/Core/JobSystem.hpp"

// Создание задания
Wudgine::Core::Job myJob = []() {
    // Код, который будет выполнен в отдельном потоке
    for (int i = 0; i < 1000; i++) {
        // Вычисления
    }
};

// Запуск задания
Wudgine::Core::JobHandle handle = Wudgine::Core::JobSystem::Schedule(myJob);

// Ожидание завершения задания
handle.Wait();
```

### Работа с зависимостями

```cpp
// Создание первого задания
Wudgine::Core::Job job1 = []() {
    // Первая часть вычислений
};

// Запуск первого задания
Wudgine::Core::JobHandle handle1 = Wudgine::Core::JobSystem::Schedule(job1);

// Создание второго задания, зависящего от первого
Wudgine::Core::Job job2 = []() {
    // Вторая часть вычислений, использующая результаты первой
};

// Запуск второго задания с зависимостью от первого
Wudgine::Core::JobHandle handle2 = Wudgine::Core::JobSystem::Schedule(job2, handle1);

// Ожидание завершения всех заданий
handle2.Wait(); // Неявно ожидает также завершения handle1
```

### Параллельные циклы

Система заданий Wudgine предоставляет удобные методы для параллельного выполнения циклов:

```cpp
std::vector<Entity> entities(10000);

// Параллельная обработка массива сущностей
Wudgine::Core::JobSystem::ParallelFor(0, entities.size(), [&entities](int index) {
    // Обработка сущности
    ProcessEntity(entities[index]);
});
```

## Параллельное выполнение систем ECS

Wudgine позволяет выполнять системы ECS параллельно, что значительно повышает производительность при большом количестве сущностей.

### Настройка параллельного выполнения

```cpp
class MySystem : public Wudgine::ECS::System {
public:
    MySystem() {
        // Указываем, что система может выполняться параллельно
        SetParallelExecution(true);
    }

    void Update(float deltaTime) override {
        // Код системы будет автоматически распараллелен
        auto view = GetWorld()->GetRegistry().view<ComponentA, ComponentB>();
        
        // Этот цикл будет выполнен параллельно
        view.each([deltaTime](auto entity, ComponentA& a, ComponentB& b) {
            // Обработка компонентов
        });
    }
};
```

### Зависимости между системами

Для корректной работы параллельных систем важно правильно настроить зависимости между ними:

```cpp
// В методе инициализации мира или сцены
void InitializeSystems() {
    auto& world = GetWorld();
    
    // Создаем системы
    auto& physicsSystem = world->AddSystem<PhysicsSystem>();
    auto& animationSystem = world->AddSystem<AnimationSystem>();
    auto& renderSystem = world->AddSystem<RenderSystem>();
    
    // Настраиваем зависимости
    // AnimationSystem будет выполняться только после PhysicsSystem
    animationSystem.AddDependency(physicsSystem);
    
    // RenderSystem будет выполняться только после AnimationSystem
    renderSystem.AddDependency(animationSystem);
}
```

## Асинхронная загрузка ресурсов

Wudgine предоставляет механизмы для асинхронной загрузки ресурсов, что позволяет избежать задержек во время игрового процесса.

### Загрузка текстур

```cpp
// Асинхронная загрузка текстуры
Wudgine::Resources::TextureHandle textureHandle = 
    Wudgine::Resources::ResourceManager::LoadTextureAsync("textures/character.png");

// Проверка готовности ресурса
if (textureHandle.IsReady()) {
    // Использование текстуры
    auto& texture = textureHandle.Get();
    // ...
} else {
    // Отображение заглушки или индикатора загрузки
}
```

### Загрузка моделей

```cpp
// Асинхронная загрузка модели
Wudgine::Resources::ModelHandle modelHandle = 
    Wudgine::Resources::ResourceManager::LoadModelAsync("models/character.fbx");

// Установка callback-функции, которая будет вызвана после загрузки
modelHandle.SetOnLoadedCallback([](const Wudgine::Resources::Model& model) {
    // Код, выполняемый после загрузки модели
    std::cout << "Model loaded with " << model.GetMeshCount() << " meshes" << std::endl;
});
```

## Потокобезопасные структуры данных

Wudgine предоставляет набор потокобезопасных структур данных для безопасного обмена информацией между потоками.

### Атомарные операции

```cpp
#include "Wudgine/Core/Atomic.hpp"

// Атомарный счетчик
Wudgine::Core::AtomicInt counter(0);

// Инкремент счетчика из разных потоков
counter.Increment();

// Получение значения
int value = counter.Get();
```

### Потокобезопасная очередь

```cpp
#include "Wudgine/Core/ConcurrentQueue.hpp"

// Создание потокобезопасной очереди
Wudgine::Core::ConcurrentQueue<int> queue;

// Добавление элементов (может вызываться из любого потока)
queue.Push(42);

// Извлечение элементов (может вызываться из любого потока)
int value;
if (queue.TryPop(value)) {
    // Успешно извлечен элемент
    std::cout << "Popped value: " << value << std::endl;
}
```

## Блокировки и синхронизация

Wudgine предоставляет различные примитивы синхронизации для безопасного доступа к разделяемым ресурсам.

### Мьютексы

```cpp
#include "Wudgine/Core/Mutex.hpp"

// Создание мьютекса
Wudgine::Core::Mutex mutex;

// Защита критической секции
{
    Wudgine::Core::MutexLock lock(mutex);
    // Код, требующий эксклюзивного доступа
}
```

### Условные переменные

```cpp
#include "Wudgine/Core/ConditionVariable.hpp"

Wudgine::Core::Mutex mutex;
Wudgine::Core::ConditionVariable cv;
bool dataReady = false;

// Поток-производитель
void Producer() {
    // Подготовка данных
    
    {
        Wudgine::Core::MutexLock lock(mutex);
        dataReady = true;
    }
    
    // Уведомление потребителя
    cv.NotifyOne();
}

// Поток-потребитель
void Consumer() {
    Wudgine::Core::MutexLock lock(mutex);
    
    // Ожидание готовности данных
    cv.Wait(lock, []{ return dataReady; });
    
    // Обработка данных
}
```

## Лучшие практики многопоточного программирования

### Избегайте гонок данных

- Используйте мьютексы или атомарные операции для защиты разделяемых данных
- Минимизируйте время блокировки мьютексов
- По возможности используйте локальные копии данных

### Минимизируйте блокировки

- Используйте lock-free алгоритмы, где это возможно
- Разделяйте данные на независимые части для параллельной обработки
- Используйте fine-grained locking вместо глобальных блокировок

### Оптимизируйте производительность

- Учитывайте кэш-линии процессора при проектировании структур данных
- Используйте пакетную обработку для минимизации накладных расходов
- Балансируйте нагрузку между потоками

## Отладка многопоточного кода

Wudgine предоставляет инструменты для отладки многопоточного кода:

- **Профилирование потоков** — анализ времени выполнения заданий в разных потоках
- **Визуализация зависимостей** — графическое представление зависимостей между заданиями
- **Детектирование гонок данных** — инструменты для выявления потенциальных проблем синхронизации

## Примеры использования

### Параллельная физическая симуляция

```cpp
class ParallelPhysicsSystem : public Wudgine::ECS::System {
public:
    ParallelPhysicsSystem() {
        SetParallelExecution(true);
    }
    
    void Update(float deltaTime) override {
        auto view = GetWorld()->GetRegistry().view<RigidBodyComponent, TransformComponent>();
        
        // Разделение пространства на сетку для параллельной обработки
        std::vector<std::vector<Entity>> spatialGrid = DivideSpatialGrid(view);
        
        // Создание заданий для каждой ячейки сетки
        std::vector<Wudgine::Core::JobHandle> handles;
        
        for (auto& cell : spatialGrid) {
            auto handle = Wudgine::Core::JobSystem::Schedule([this, &cell, deltaTime]() {
                // Обработка физики для сущностей в ячейке
                for (auto entity : cell) {
                    UpdatePhysics(entity, deltaTime);
                }
            });
            
            handles.push_back(handle);
        }
        
        // Ожидание завершения всех заданий
        for (auto& handle : handles) {
            handle.Wait();
        }
        
        // Разрешение коллизий между ячейками
        ResolveInterCellCollisions(spatialGrid);
    }
    
private:
    // Вспомогательные методы
};
```

### Асинхронная генерация процедурного контента

```cpp
class ProceduralTerrainGenerator {
public:
    void GenerateTerrainAsync(int width, int height, float scale) {
        // Создание задания для генерации карты высот
        auto heightmapJob = Wudgine::Core::JobSystem::Schedule([this, width, height, scale]() {
            m_HeightMap = GenerateHeightMap(width, height, scale);
        });
        
        // Создание задания для генерации текстур, зависящего от карты высот
        auto textureJob = Wudgine::Core::JobSystem::Schedule([this]() {
            m_DiffuseMap = GenerateDiffuseMap(m_HeightMap);
            m_NormalMap = GenerateNormalMap(m_HeightMap);
        }, heightmapJob);
        
        // Создание задания для генерации меша, зависящего от карты высот
        auto meshJob = Wudgine::Core::JobSystem::Schedule([this]() {
            m_Mesh = GenerateMesh(m_HeightMap);
        }, heightmapJob);
        
        // Создание задания для финальной сборки, зависящего от текстур и меша
        m_FinalHandle = Wudgine::Core::JobSystem::Schedule([this]() {
            m_Terrain = CreateTerrain(m_Mesh, m_DiffuseMap, m_NormalMap);
            m_IsReady = true;
            
            if (m_OnCompletedCallback) {
                m_OnCompletedCallback(m_Terrain);
            }
        }, Wudgine::Core::JobHandle::CombineDependencies(textureJob, meshJob));
    }
    
    bool IsReady() const { return m_IsReady; }
    
    void SetOnCompletedCallback(std::function<void(const Terrain&)> callback) {
        m_OnCompletedCallback = std::move(callback);
    }
    
private:
    // Данные и вспомогательные методы
    HeightMap m_HeightMap;
    Texture m_DiffuseMap;
    Texture m_NormalMap;
    Mesh m_Mesh;
    Terrain m_Terrain;
    
    bool m_IsReady = false;
    Wudgine::Core::JobHandle m_FinalHandle;
    std::function<void(const Terrain&)> m_OnCompletedCallback;
};
```

## Что дальше?

- Изучите [оптимизацию производительности](/ru/advanced-topics/performance-optimization) для дальнейшего улучшения быстродействия вашей игры
- Ознакомьтесь с [сетевым взаимодействием](/ru/advanced-topics/networking) для создания многопользовательских игр
- Исследуйте [расширенную работу с ресурсами](/ru/advanced-topics/advanced-resources) для оптимизации загрузки и управления игровыми ресурсами

::alert{type="warning"}
Многопоточное программирование может быть сложным и подверженным ошибкам. Всегда тщательно тестируйте ваш код и используйте инструменты профилирования для выявления проблем производительности и синхронизации.
::