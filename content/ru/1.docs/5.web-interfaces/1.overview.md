::callout{type="info"}
В этом разделе представлен обзор системы веб-интерфейсов Wudgine, которая позволяет создавать пользовательские интерфейсы с использованием HTML, CSS и JavaScript.
::

## Введение

Wudgine предоставляет мощную систему веб-интерфейсов, основанную на библиотеке Ultralight, которая позволяет разработчикам создавать игровые интерфейсы с использованием стандартных веб-технологий.

::callout{type="tip"}
Использование веб-технологий для UI позволяет значительно ускорить разработку интерфейсов и привлекать веб-разработчиков к созданию игрового UI.
::

## Архитектура веб-подсистемы

Система веб-интерфейсов Wudgine состоит из следующих основных компонентов:

::list{type="primary"}
- **WebView**: Основной компонент для рендеринга веб-содержимого
- **JavaScript Bridge**: Мост между C++ и JavaScript для двусторонней коммуникации
- **WebUI Component**: Компонент ECS для интеграции веб-интерфейсов в игровые объекты
- **WebUI System**: Система ECS для обновления и рендеринга веб-интерфейсов
- **WebUI Resource**: Ресурс для загрузки и управления веб-содержимым
::

## Основные возможности

### Рендеринг HTML/CSS

Wudgine поддерживает большинство современных стандартов HTML5 и CSS3, включая:

::list{type="success"}
- Flexbox и Grid для создания адаптивных макетов
- CSS-анимации и переходы
- Шрифты и иконки
- SVG-графика
- Медиа-запросы для адаптивного дизайна
::

```html
<!-- Пример HTML-структуры для игрового интерфейса -->
<div class="game-ui">
  <header class="top-bar">
    <div class="health-container">
      <div class="health-bar" style="width: 75%"></div>
    </div>
    <div class="resources">
      <span class="gold">1250</span>
      <span class="gems">7</span>
    </div>
  </header>
  
  <div class="inventory-grid">
    <!-- Ячейки инвентаря будут добавлены через JavaScript -->
  </div>
  
  <footer class="action-bar">
    <button class="action-button" data-action="attack">Атака</button>
    <button class="action-button" data-action="defend">Защита</button>
    <button class="action-button" data-action="special">Особый навык</button>
  </footer>
</div>
```

```css
/* Пример CSS для игрового интерфейса */
.game-ui {
  display: flex;
  flex-direction: column;
  height: 100%;
  font-family: 'GameFont', sans-serif;
  color: #e0e0e0;
}

.top-bar {
  display: flex;
  justify-content: space-between;
  padding: 10px;
  background: rgba(0, 0, 0, 0.7);
}

.health-container {
  width: 200px;
  height: 20px;
  background: #333;
  border: 2px solid #555;
  border-radius: 10px;
  overflow: hidden;
}

.health-bar {
  height: 100%;
  background: linear-gradient(to right, #f00, #f55);
  transition: width 0.3s ease-out;
}

.inventory-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 10px;
  padding: 20px;
  flex-grow: 1;
}

.inventory-slot {
  aspect-ratio: 1;
  background: rgba(0, 0, 0, 0.5);
  border: 2px solid #555;
  border-radius: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.action-bar {
  display: flex;
  justify-content: space-around;
  padding: 10px;
  background: rgba(0, 0, 0, 0.7);
}

.action-button {
  padding: 10px 20px;
  background: linear-gradient(to bottom, #555, #333);
  border: 2px solid #777;
  border-radius: 5px;
  color: #e0e0e0;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s;
}

.action-button:hover {
  background: linear-gradient(to bottom, #666, #444);
  transform: scale(1.05);
}

.action-button:active {
  background: linear-gradient(to bottom, #444, #222);
  transform: scale(0.95);
}
```

### JavaScript-интеграция

Wudgine предоставляет двустороннюю коммуникацию между C++ и JavaScript:

::code-group
```cpp [C++ код]
// Регистрация C++ функции для вызова из JavaScript
auto& webUI = entity.getComponent<WebUIComponent>();
webUI.registerFunction("addItemToInventory", [](const json& args) -> json {
    int itemId = args["itemId"];
    std::string itemName = args["name"];
    
    // Логика добавления предмета в инвентарь
    InventoryManager::getInstance().addItem(itemId, itemName);
    
    // Возвращаем результат в JavaScript
    return {
        {"success", true},
        {"newCount", InventoryManager::getInstance().getItemCount(itemId)}
    };
});

// Вызов JavaScript-функции из C++
json result = webUI.callJavaScriptFunction("updateInventoryUI", {
    {"items", InventoryManager::getInstance().getAllItems()},
    {"maxSlots", 25}
});

bool success = result["success"];
```

```js [JavaScript код]
// Вызов C++ функции из JavaScript
function onAddItemButtonClick(itemId, itemName) {
    // Вызов зарегистрированной C++ функции
    const result = engine.call('addItemToInventory', {
        itemId: itemId,
        name: itemName
    });
    
    if (result.success) {
        console.log(`Предмет добавлен! Новое количество: ${result.newCount}`);
        showNotification(`Получен предмет: ${itemName}`);
    }
}

// Функция, вызываемая из C++
function updateInventoryUI(data) {
    const inventoryContainer = document.querySelector('.inventory-grid');
    inventoryContainer.innerHTML = '';
    
    // Создание слотов инвентаря
    for (let i = 0; i < data.maxSlots; i++) {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        
        // Если в этом слоте есть предмет
        const item = data.items[i];
        if (item) {
            slot.innerHTML = `
                <img src="assets/items/${item.icon}" alt="${item.name}">
                <span class="item-count">${item.count}</span>
                <div class="item-tooltip">${item.name}</div>
            `;
            slot.setAttribute('data-item-id', item.id);
            slot.addEventListener('click', () => onItemClick(item.id));
        }
        
        inventoryContainer.appendChild(slot);
    }
    
    return { success: true };
}

// Регистрация функции для вызова из C++
engine.register('updateInventoryUI', updateInventoryUI);
```
::

### Интеграция с ECS

Wudgine предоставляет компонент `WebUIComponent` для интеграции веб-интерфейсов в сущности ECS:

```cpp
// Создание сущности с веб-интерфейсом
Entity uiEntity = world.createEntity("InventoryUI");

// Добавление компонента WebUI
auto& webUI = uiEntity.addComponent<WebUIComponent>();
webUI.setSource("assets/ui/inventory.html");
webUI.setSize(800, 600);
webUI.setTransparent(true);
webUI.setInteractive(true);

// Настройка позиции и размера в 3D-пространстве
auto& transform = uiEntity.getComponent<TransformComponent>();
transform.position = Vector3(0.0f, 1.7f, 0.5f);
transform.rotation = Quaternion::fromEuler(0.0f, 180.0f, 0.0f);
transform.scale = Vector3(0.002f, 0.002f, 0.002f);

// Регистрация обработчиков событий
webUI.onLoadComplete([&uiEntity]() {
    Debug::log("UI загружен: {}", uiEntity.getName());
    
    // Инициализация UI после загрузки
    auto& webUI = uiEntity.getComponent<WebUIComponent>();
    webUI.callJavaScriptFunction("initializeUI", {
        {"playerName", "Герой"},
        {"level", 5},
        {"maxHealth", 100},
        {"currentHealth", 75}
    });
});
```

## Примеры использования

### Внутриигровой HUD

```cpp
// Создание HUD
Entity hud = world.createEntity("PlayerHUD");
auto& webUI = hud.addComponent<WebUIComponent>();
webUI.setSource("assets/ui/hud.html");
webUI.setSize(1920, 1080);
webUI.setFullscreen(true);
webUI.setTransparent(true);
webUI.setInteractive(false);

// Система для обновления HUD
class HUDSystem : public ISystem {
private:
    World* m_world;
    Entity m_player;
    Entity m_hud;

public:
    HUDSystem(World* world) : m_world(world) {
        m_player = world->findEntityByName("Player");
        m_hud = world->findEntityByName("PlayerHUD");
    }

    void update(float deltaTime) override {
        if (!m_player.isValid() || !m_hud.isValid()) return;
        
        auto& health = m_player.getComponent<HealthComponent>();
        auto& inventory = m_player.getComponent<InventoryComponent>();
        auto& webUI = m_hud.getComponent<WebUIComponent>();
        
        // Обновление HUD
        webUI.callJavaScriptFunction("updateHUD", {
            {"health", health.currentHealth},
            {"maxHealth", health.maxHealth},
            {"stamina", m_player.getComponent<StaminaComponent>().currentStamina},
            {"maxStamina", m_player.getComponent<StaminaComponent>().maxStamina},
            {"gold", inventory.gold},
            {"ammo", inventory.getAmmoCount()}
        });
    }
};
```

### Инвентарь и меню

```cpp
// Создание инвентаря
Entity inventoryUI = world.createEntity("InventoryUI");
auto& webUI = inventoryUI.addComponent<WebUIComponent>();
webUI.setSource("assets/ui/inventory.html");
webUI.setSize(1200, 800);
webUI.setVisible(false); // Изначально скрыт
webUI.setInteractive(true);

// Регистрация обработчиков событий
webUI.registerFunction("useItem", [&inventoryUI](const json& args) -> json {
    int itemId = args["itemId"];
    
    // Получение игрока
    Entity player = world.findEntityByName("Player");
    if (!player.isValid()) {
        return {{"success", false}, {"error", "Player not found"}};
    }
    
    // Использование предмета
    bool success = player.getComponent<InventoryComponent>().useItem(itemId);
    
    return {{"success", success}};
});

// Система для открытия/закрытия инвентаря
class InventoryUISystem : public ISystem {
private:
    World* m_world;
    Entity m_inventoryUI;
    InputManager* m_inputManager;

public:
    InventoryUISystem(World* world, InputManager* inputManager) 
        : m_world(world), m_inputManager(inputManager) {
        m_inventoryUI = world->findEntityByName("InventoryUI");
        
        // Регистрация обработчика клавиши
        m_inputManager->registerKeyCallback(KeyCode::I, [this](bool pressed) {
            if (pressed) {
                toggleInventory();
            }
        });
    }

    void toggleInventory() {
        if (!m_inventoryUI.isValid()) return;
        
        auto& webUI = m_inventoryUI.getComponent<WebUIComponent>();
        bool isVisible = webUI.isVisible();
        
        webUI.setVisible(!isVisible);
        
        if (!isVisible) {
            // Обновление данных при открытии инвентаря
            Entity player = m_world->findEntityByName("Player");
            if (player.isValid()) {
                auto& inventory = player.getComponent<InventoryComponent>();
                webUI.callJavaScriptFunction("updateInventoryUI", {
                    {"items", inventory.getAllItems()},
                    {"maxSlots", inventory.getMaxSlots()}
                });
            }
        }
    }
};
```

## Оптимизация производительности

Для оптимальной производительности веб-интерфейсов следуйте этим рекомендациям:

::list{type="warning"}
- Минимизируйте количество DOM-элементов
- Используйте CSS-анимации вместо JavaScript-анимаций
- Избегайте сложных селекторов CSS
- Оптимизируйте изображения и используйте спрайты
- Минимизируйте количество вызовов между C++ и JavaScript
- Используйте пулинг для часто создаваемых элементов
::

```js
// Пример оптимизации с использованием пулинга элементов
class ElementPool {
    constructor(tagName, className, parent, initialCount = 10) {
        this.pool = [];
        this.parent = parent;
        
        // Создание начального пула элементов
        for (let i = 0; i < initialCount; i++) {
            const element = document.createElement(tagName);
            element.className = className;
            element.style.display = 'none';
            parent.appendChild(element);
            this.pool.push(element);
        }
    }
    
    get() {
        // Получение элемента из пула или создание нового
        let element;
        if (this.pool.length > 0) {
            element = this.pool.pop();
        } else {
            element = document.createElement(tagName);
            element.className = className;
            this.parent.appendChild(element);
        }
        
        element.style.display = '';
        return element;
    }
    
    release(element) {
        // Возврат элемента в пул
        element.style.display = 'none';
        this.pool.push(element);
    }
}

// Использование пула для создания частиц
const particleContainer = document.querySelector('.particle-container');
const particlePool = new ElementPool('div', 'particle', particleContainer, 50);

function createParticle(x, y) {
    const particle = particlePool.get();
    particle.style.left = `${x}px`;
    particle.style.top = `${y}px`;
    
    // Анимация частицы
    setTimeout(() => {
        particlePool.release(particle);
    }, 1000);
}
```

## Отладка веб-интерфейсов

Wudgine предоставляет инструменты для отладки веб-интерфейсов:

::list{type="primary"}
- Встроенная консоль JavaScript
- Инспектор DOM-элементов
- Отладка сетевых запросов
- Профилирование производительности
::

```cpp
// Включение инструментов разработчика для веб-интерфейса
auto& webUI = entity.getComponent<WebUIComponent>();
webUI.enableDevTools(true);

// Вывод сообщений в консоль JavaScript
webUI.executeJavaScript("console.log('Отладочное сообщение');");

// Получение ошибок JavaScript
webUI.onJavaScriptError([](const std::string& errorMessage, 
                          const std::string& sourceFile, 
                          int lineNumber) {
    Debug::logError("JavaScript Error: {} in {} at line {}", 
                   errorMessage, sourceFile, lineNumber);
});
```

## Следующие шаги

Теперь, когда вы ознакомились с основами веб-интерфейсов в Wudgine, рекомендуем:

::card-group
  :::card{icon="i-lucide-code" title="JavaScript API" to="/ru/5.web-interfaces/2.javascript-api"}
  Изучите JavaScript API для взаимодействия с движком.
  :::
  :::card{icon="i-lucide-layout" title="UI компоненты" to="/ru/5.web-interfaces/3.ui-components"}
  Узнайте о готовых UI компонентах и шаблонах.
  :::
  :::card{icon="i-lucide-puzzle" title="Плагины" to="/ru/6.plugins/1.overview"}
  Изучите систему плагинов Wudgine.
  :::
::