::alert{type="info"}
API плагинов Wudgine предоставляет набор интерфейсов и хуков для взаимодействия с ядром движка.
::

## Основные интерфейсы

Система плагинов Wudgine построена вокруг нескольких ключевых интерфейсов:

### IPlugin

Базовый интерфейс для всех плагинов:

```cpp
namespace Wudgine::Plugin {

class IPlugin {
public:
    virtual ~IPlugin() = default;

    // Жизненный цикл
    virtual bool Initialize() = 0;
    virtual void Shutdown() = 0;
    
    // Метаданные
    virtual const char* GetName() const = 0;
    virtual const char* GetVersion() const = 0;
    virtual const char* GetAuthor() const = 0;
    virtual const char* GetDescription() const = 0;
    
    // Настройки (опционально)
    virtual void RenderSettings() {}
    
    // Проверка совместимости
    virtual bool IsCompatibleWithEngineVersion(const char* version) const;
};

} // namespace Wudgine::Plugin
```

### PluginManager

Менеджер плагинов отвечает за загрузку, инициализацию и управление плагинами:

```cpp
namespace Wudgine::Core {

class PluginManager {
public:
    static PluginManager& GetInstance();
    
    // Загрузка плагинов
    bool LoadPlugin(const std::string& name);
    bool LoadPluginFromPath(const std::string& path);
    bool LoadAllPlugins();
    
    // Управление плагинами
    bool InitializePlugin(const std::string& name);
    void ShutdownPlugin(const std::string& name);
    void ShutdownAllPlugins();
    
    // Доступ к плагинам
    Plugin::IPlugin* GetPlugin(const std::string& name);
    bool IsPluginLoaded(const std::string& name) const;
    std::vector<Plugin::IPlugin*> GetAllPlugins() const;
    
    // Зависимости
    bool ResolveDependencies(const std::string& name);
};

} // namespace Wudgine::Core
```

## Хуки плагинов

Хуки позволяют плагинам встраиваться в различные части движка:

### Хуки жизненного цикла

```cpp
// В вашем плагине
bool MyPlugin::Initialize() {
    // Регистрация хуков
    Wudgine::Core::HookSystem::GetInstance().RegisterHook<Wudgine::Core::Hooks::OnSceneLoad>(
        [this](Wudgine::Core::Scene* scene) {
            // Код, выполняемый при загрузке сцены
            return true; // Продолжить выполнение других хуков
        }
    );
    
    return true;
}
```

### Доступные хуки

::list{type="primary"}
- **OnEngineInitialize** — вызывается при инициализации движка
- **OnEngineShutdown** — вызывается при завершении работы движка
- **OnSceneLoad** — вызывается при загрузке сцены
- **OnSceneSave** — вызывается при сохранении сцены
- **OnSceneUnload** — вызывается при выгрузке сцены
- **OnUpdate** — вызывается каждый кадр
- **OnFixedUpdate** — вызывается с фиксированной частотой
- **OnRender** — вызывается при отрисовке
- **OnGUI** — вызывается при отрисовке GUI
::

## Расширение редактора

API плагинов позволяет расширять редактор Wudgine:

### Инструменты редактора

```cpp
// Создание инструмента редактора
class MyEditorTool : public Wudgine::Editor::EditorTool {
public:
    const char* GetName() const override { return "Мой инструмент"; }
    const char* GetIcon() const override { return "path/to/icon.png"; }
    
    void Initialize() override {
        // Инициализация инструмента
    }
    
    void Render() override {
        // Отрисовка интерфейса инструмента
        ImGui::Begin(GetName());
        ImGui::Text("Содержимое инструмента");
        ImGui::End();
    }
};

// Регистрация инструмента в плагине
bool MyPlugin::Initialize() {
    if (Wudgine::Core::IsEditor()) {
        auto* tool = new MyEditorTool();
        Wudgine::Editor::EditorToolManager::GetInstance().RegisterTool(tool);
    }
    
    return true;
}
```

### Инспекторы компонентов

```cpp
// Создание инспектора для компонента
class MyComponentInspector : public Wudgine::Editor::ComponentInspector {
public:
    bool CanInspect(Wudgine::ECS::Component* component) override {
        return dynamic_cast<MyPluginComponent*>(component) != nullptr;
    }
    
    void Render(Wudgine::ECS::Component* component) override {
        auto* myComponent = static_cast<MyPluginComponent*>(component);
        
        // Отрисовка полей компонента
        float value = myComponent->GetValue();
        if (ImGui::DragFloat("Значение", &value)) {
            myComponent->SetValue(value);
            MarkDirty();
        }
    }
};

// Регистрация инспектора в плагине
bool MyPlugin::Initialize() {
    if (Wudgine::Core::IsEditor()) {
        auto* inspector = new MyComponentInspector();
        Wudgine::Editor::InspectorManager::GetInstance().RegisterInspector(inspector);
    }
    
    return true;
}
```

### Пункты меню

```cpp
// Добавление пункта меню
bool MyPlugin::Initialize() {
    if (Wudgine::Core::IsEditor()) {
        Wudgine::Editor::EditorMenuManager::GetInstance().AddMenuItem(
            "Инструменты/Мой плагин/Действие",
            [this]() {
                // Действие при выборе пункта меню
                WG_LOG_INFO("Выполнено действие из меню");
            }
        );
    }
    
    return true;
}
```

## Работа с ресурсами

API плагинов предоставляет доступ к системе ресурсов:

```cpp
// Загрузка ресурса
bool MyPlugin::Initialize() {
    // Загрузка текстуры
    auto* texture = Wudgine::Resource::ResourceManager::GetInstance().LoadTexture("path/to/texture.png");
    if (texture) {
        // Использование текстуры
    }
    
    // Загрузка модели
    auto* model = Wudgine::Resource::ResourceManager::GetInstance().LoadModel("path/to/model.fbx");
    if (model) {
        // Использование модели
    }
    
    return true;
}
```

## Работа с настройками

API плагинов позволяет сохранять и загружать настройки:

```cpp
// Определение структуры настроек
struct MyPluginSettings {
    bool enableFeature = true;
    int quality = 5;
    std::string outputPath = "output";
    
    // Сериализация настроек
    template<typename Archive>
    void serialize(Archive& ar) {
        ar & enableFeature;
        ar & quality;
        ar & outputPath;
    }
};

// В вашем плагине
class MyPlugin : public Wudgine::Plugin::IPlugin {
private:
    MyPluginSettings m_settings;
    
public:
    bool Initialize() override {
        // Загрузка настроек
        if (Wudgine::Core::SettingsManager::GetInstance().HasPluginSettings(GetName())) {
            m_settings = Wudgine::Core::SettingsManager::GetInstance().LoadPluginSettings<MyPluginSettings>(GetName());
        }
        
        return true;
    }
    
    void RenderSettings() override {
        // Отображение настроек в редакторе
        ImGui::Checkbox("Включить функцию", &m_settings.enableFeature);
        ImGui::SliderInt("Качество", &m_settings.quality, 1, 10);
        
        // Сохранение настроек при изменении
        Wudgine::Core::SettingsManager::GetInstance().SavePluginSettings(
            GetName(), m_settings
        );
    }
};
```

## Взаимодействие между плагинами

Плагины могут взаимодействовать друг с другом:

```cpp
// Получение другого плагина
bool MyPlugin::Initialize() {
    // Проверка наличия другого плагина
    if (Wudgine::Core::PluginManager::GetInstance().IsPluginLoaded("OtherPlugin")) {
        // Получение другого плагина
        auto* otherPlugin = static_cast<OtherPlugin*>(
            Wudgine::Core::PluginManager::GetInstance().GetPlugin("OtherPlugin")
        );
        
        // Взаимодействие с другим плагином
        otherPlugin->DoSomething();
    }
    
    return true;
}
```

## Сервисы плагинов

Плагины могут предоставлять сервисы для других плагинов:

```cpp
// Определение интерфейса сервиса
class IMyService {
public:
    virtual ~IMyService() = default;
    virtual void DoSomething() = 0;
};

// Реализация сервиса
class MyService : public IMyService {
public:
    void DoSomething() override {
        // Реализация
    }
};

// Регистрация сервиса в плагине
bool MyPlugin::Initialize() {
    // Создание и регистрация сервиса
    auto* service = new MyService();
    Wudgine::Core::ServiceLocator::GetInstance().RegisterService<IMyService>(service);
    
    return true;
}

// Использование сервиса в другом плагине
bool OtherPlugin::Initialize() {
    // Получение сервиса
    auto* service = Wudgine::Core::ServiceLocator::GetInstance().GetService<IMyService>();
    if (service) {
        // Использование сервиса
        service->DoSomething();
    }
    
    return true;
}
```

## Обработка событий

API плагинов позволяет работать с системой событий:

```cpp
// Определение события
struct MyEvent {
    int value;
    std::string message;
};

// Подписка на событие
bool MyPlugin::Initialize() {
    // Подписка на событие
    Wudgine::Core::EventSystem::GetInstance().Subscribe<MyEvent>(
        [this](const MyEvent& event) {
            WG_LOG_INFO("Получено событие: {} - {}", event.value, event.message);
        }
    );
    
    return true;
}

// Отправка события
void MyPlugin::DoSomething() {
    // Отправка события
    MyEvent event;
    event.value = 42;
    event.message = "Привет, мир!";
    
    Wudgine::Core::EventSystem::GetInstance().Publish(event);
}
```

## Многопоточность

API плагинов предоставляет инструменты для работы с многопоточностью:

```cpp
// Использование пула потоков
bool MyPlugin::Initialize() {
    // Отправка задачи в пул потоков
    Wudgine::Core::ThreadPool::GetInstance().Enqueue(
        []() {
            // Код, выполняемый в отдельном потоке
            WG_LOG_INFO("Задача выполняется в отдельном потоке");
        }
    );
    
    return true;
}
```

## Что дальше?

Теперь, когда вы знакомы с API плагинов, вы можете:

- Посмотреть [примеры готовых плагинов](/ru/plugins/plugin-examples)
- Узнать, как [публиковать свои плагины](/ru/plugins/publishing-plugins)

::alert{type="success"}
API плагинов Wudgine предоставляет широкие возможности для расширения функциональности движка. Экспериментируйте и создавайте уникальные решения для своих проектов!
::